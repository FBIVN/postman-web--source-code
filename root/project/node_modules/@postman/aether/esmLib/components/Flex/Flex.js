function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

import React from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import { globals, aliases } from '../../design-tokens/tokens';
import { hiddenForToClass } from '../../utils/common/index';
/**
 * @description This function verifies whether provided values are defined spacing design tokens
 * and warns otherwise.
 * @param {string} paddingValues padding values in a form of space separated string
 */

function validatePadding(paddingValues) {
  for (var index = 0; index < paddingValues.length; index += 1) {
    var paddingProp = paddingValues[index];

    if (!globals.spacing[paddingProp]) {
      // eslint-disable-next-line no-console
      console.warn("Flex: ".concat(paddingProp, " Unsupported value provided, Please provide values from the given list ").concat(Object.keys(globals.spacing)));
    }
  }
}

function getPadding(padding) {
  var paddingValues = [];

  if (_typeof(padding) === 'object') {
    var paddingTop = padding.paddingTop,
        paddingBottom = padding.paddingBottom,
        paddingLeft = padding.paddingLeft,
        paddingRight = padding.paddingRight;
    return "\n      ".concat(paddingTop ? "padding-top: ".concat(globals.spacing[paddingTop], ";") : '', "\n      ").concat(paddingBottom ? "padding-bottom: ".concat(globals.spacing[paddingBottom], ";") : '', "\n      ").concat(paddingLeft ? "padding-left: ".concat(globals.spacing[paddingLeft], ";") : '', "\n      ").concat(paddingRight ? "padding-right: ".concat(globals.spacing[paddingRight], ";") : '', "\n    ");
  } // case when padding is provided as string


  paddingValues = padding.split(' '); // verifies whether provided values are defined spacing design tokens and warns otherwise

  validatePadding(paddingValues);

  switch (paddingValues.length) {
    case 1:
      return "padding: ".concat(globals.spacing[paddingValues[0]], ";");

    case 2:
      return "padding: ".concat(globals.spacing[paddingValues[0]], " ").concat(globals.spacing[paddingValues[1]], ";");

    case 3:
      return "padding: ".concat(globals.spacing[paddingValues[0]], " ").concat(globals.spacing[paddingValues[1]], " ").concat(globals.spacing[paddingValues[2]], ";");

    case 4:
      return "\n        padding: ".concat(globals.spacing[paddingValues[0]], "\n          ").concat(globals.spacing[paddingValues[1]], "\n          ").concat(globals.spacing[paddingValues[2]], "\n          ").concat(globals.spacing[paddingValues[3]], ";");

    default:
      return '';
  }
}

function getBorderStyles(_ref, theme) {
  var border = _ref.border,
      borderTop = _ref.borderTop,
      borderBottom = _ref.borderBottom,
      borderLeft = _ref.borderLeft,
      borderRight = _ref.borderRight,
      borderColor = _ref.borderColor,
      borderStyle = _ref.borderStyle;
  return "\n    ".concat(border ? "border: ".concat(globals.border[border], " ").concat(globals.border['border-style-solid'], " ").concat(theme['border-color-default'], ";") : '', "\n    ").concat(borderTop ? "border-top: ".concat(globals.border[borderTop], " ").concat(globals.border['border-style-solid'], " ").concat(theme['border-color-default'], ";") : '', "\n    ").concat(borderBottom ? "border-bottom: ".concat(globals.border[borderBottom], " ").concat(globals.border['border-style-solid'], " ").concat(theme['border-color-default'], ";") : '', "\n    ").concat(borderLeft ? "border-left: ".concat(globals.border[borderLeft], " ").concat(globals.border['border-style-solid'], " ").concat(theme['border-color-default'], ";") : '', "\n    ").concat(borderRight ? "border-right: ".concat(globals.border[borderRight], " ").concat(globals.border['border-style-solid'], " ").concat(theme['border-color-default'], ";") : '', "\n    ").concat(borderColor ? "border-color: ".concat(theme[borderColor], ";") : '', "\n    ").concat(borderStyle ? "border-style: ".concat(globals.border[borderStyle], ";") : '', "\n  ");
} // FLex styled element


var StyledFlex = styled.div.withConfig({
  displayName: "Flex__StyledFlex",
  componentId: "sc-1dwxyxa-0"
})(["box-sizing:border-box;display:", ";", " ", ";", ";", " border-radius:", ";background-color:", ";justify-content:", ";align-items:", ";align-self:", ";flex-shrink:", ";", " ", " ", " ", ""], function (props) {
  return props.inline ? 'inline-flex' : 'flex';
}, function (props) {
  if (props.direction === 'column') {
    return "\n        flex-direction: ".concat(props.direction, ";\n        ").concat(props.alignItems ? '' : '& > * { width: 100%; }', "\n        & > *:not(:last-child) {\n          margin-bottom: ").concat(globals.spacing[props.gap], "; \n        }\n      ");
  }

  if (props.direction === 'column-reverse') {
    return "\n        flex-direction: ".concat(props.direction, ";\n        ").concat(props.alignItems ? '' : '& > * { width: 100%; }', "\n        & > *:not(:last-child) {\n          margin-top: ").concat(globals.spacing[props.gap], ";\n        }\n      ");
  }

  if (props.direction === 'row-reverse') {
    return "\n        ".concat(props.alignItems ? '' : '& > * { height: 100%; }', "\n        flex-direction: ").concat(props.direction, ";\n        & > *:not(:last-child) {\n          margin-left: ").concat(globals.spacing[props.gap], ";\n        }\n      ");
  }

  return "\n      ".concat(props.alignItems ? '' : '& > * { height: 100%; }', "\n      flex-direction: ").concat(props.direction, ";\n      & > *:not(:last-child) {\n        margin-right: ").concat(globals.spacing[props.gap], ";\n      }\n    ");
}, function (props) {
  return props.height && "\n    height: ".concat(props.height, ";\n  ");
}, function (props) {
  return props.width && "\n    width: ".concat(props.width, ";\n  ");
}, function (props) {
  return getPadding(props.padding);
}, function (props) {
  return props.borderRadius ? props.theme[props.borderRadius] : '';
}, function (props) {
  return props.theme[props.backgroundColor];
}, function (props) {
  return props.justifyContent;
}, function (props) {
  return props.alignItems;
}, function (props) {
  return props.alignSelf;
}, function (props) {
  return props.shrink ? props.shrink : '0';
}, function (props) {
  return props.grow ? "flex-grow: ".concat(props.grow, ";") : '';
}, function (props) {
  return props.basis ? "flex-basis: ".concat(props.basis, ";") : '';
}, function (props) {
  return props.wrap ? "flex-wrap: ".concat(props.wrap, ";") : '';
}, function (props) {
  return props.border && getBorderStyles(props.border, props.theme);
});
export default function Flex(_ref2) {
  var inline = _ref2.inline,
      height = _ref2.height,
      width = _ref2.width,
      gap = _ref2.gap,
      direction = _ref2.direction,
      justifyContent = _ref2.justifyContent,
      alignItems = _ref2.alignItems,
      padding = _ref2.padding,
      grow = _ref2.grow,
      shrink = _ref2.shrink,
      basis = _ref2.basis,
      wrap = _ref2.wrap,
      alignSelf = _ref2.alignSelf,
      backgroundColor = _ref2.backgroundColor,
      border = _ref2.border,
      borderRadius = _ref2.borderRadius,
      className = _ref2.className,
      hiddenFor = _ref2.hiddenFor,
      children = _ref2.children;
  var classes = "".concat(className, " ").concat(hiddenForToClass(hiddenFor));
  return /*#__PURE__*/React.createElement(StyledFlex, {
    inline: inline,
    height: height,
    width: width,
    direction: direction,
    gap: gap,
    justifyContent: justifyContent,
    alignItems: alignItems,
    alignSelf: alignSelf,
    padding: padding,
    grow: grow,
    shrink: shrink,
    basis: basis,
    wrap: wrap,
    backgroundColor: backgroundColor,
    border: border,
    borderRadius: borderRadius,
    className: classes
  }, children);
}
Flex.defaultProps = {
  inline: false,
  height: null,
  width: null,
  gap: 'spacing-zero',
  direction: 'row',
  justifyContent: 'flex-start',
  alignItems: 'stretch',
  padding: 'spacing-zero',
  backgroundColor: 'transparent',
  grow: 0,
  shrink: 0,
  basis: 'auto',
  wrap: 'nowrap',
  border: null,
  borderRadius: null,
  alignSelf: 'auto',
  className: '',
  hiddenFor: []
};
Flex.propTypes = {
  inline: PropTypes.bool,
  height: PropTypes.string,
  width: PropTypes.string,
  grow: PropTypes.number,
  shrink: PropTypes.number,
  basis: PropTypes.string,
  alignSelf: PropTypes.oneOf(['auto', 'flex-start', 'flex-end', 'center', 'baseline', 'stretch']),
  gap: PropTypes.oneOf(Object.keys(globals.spacing)),
  wrap: PropTypes.oneOf(['nowrap', 'wrap', 'wrap-reverse']),
  direction: PropTypes.oneOf(['row', 'row-reverse', 'column', 'column-reverse']),
  justifyContent: PropTypes.oneOf(['stretch', 'center', 'flex-start', 'flex-end', 'space-between', 'space-around', 'space-evenly']),
  alignItems: PropTypes.oneOf(['stretch', 'center', 'flex-start', 'flex-end']),
  padding: PropTypes.oneOfType([PropTypes.oneOf(Object.keys(globals.spacing)), PropTypes.shape({
    paddingTop: PropTypes.string,
    paddingBottom: PropTypes.string,
    paddingLeft: PropTypes.string,
    paddingRight: PropTypes.string
  }), PropTypes.string]),
  backgroundColor: PropTypes.oneOf(['transparent'].concat(_toConsumableArray(Object.keys(globals.colors)), _toConsumableArray(Object.keys(aliases.light.background)))),
  border: PropTypes.shape({
    border: PropTypes.oneOf(['border-width-default', 'border-width-l', 'border-width-xl']),
    borderTop: PropTypes.oneOf(['border-width-default', 'border-width-l', 'border-width-xl']),
    borderBottom: PropTypes.oneOf(['border-width-default', 'border-width-l', 'border-width-xl']),
    borderLeft: PropTypes.oneOf(['border-width-default', 'border-width-l', 'border-width-xl']),
    borderRight: PropTypes.oneOf(['border-width-default', 'border-width-l', 'border-width-xl']),
    borderStyle: PropTypes.oneOf(['border-style-solid', 'border-style-dashed']),
    borderColor: PropTypes.oneOf(Object.keys(aliases.light.border))
  }),
  borderRadius: PropTypes.oneOf(['border-radius-s', 'border-radius-default', 'border-radius-max']),
  className: PropTypes.string,
  children: PropTypes.node.isRequired,
  hiddenFor: PropTypes.arrayOf(PropTypes.oneOf(['mobile', 'tablet', 'computer']))
};