function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import React, { useState } from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';
import mixins from '../../utils/common/mixins';
import Button from '../Button/Button';
import Flex from '../Flex/Flex';
import Icon from '../Icon/Icon';
import Label from '../Label/Label';
import Text from '../Text/Text';
import Tooltip from '../Tooltip/Tooltip';
var VALIDATION_STATUS_VARIANTS = ['success', 'warning', 'error'];
var TEXTINPUT_TYPE_VARIANTS = ['text', 'number', 'password', 'email', 'search'];
var TEXTINPUT_SIZE_VARIANTS = ['small', 'medium'];
/**
 * Function which returns the TextInput styles based on the current interaction state
 * @param {string} interactionState - The current interaction state of the TextInput
 * @param {string} status - Validation status of the TextInput component, possible values are error, warning or success
 */

function getInputStyles(interactionState, status, theme) {
  var statusColor = status ? "input-border-color-".concat(status) : '';

  switch (interactionState) {
    case 'hover':
      return "\n        background-color: ".concat(theme['background-color-primary'], ";\n        color: ").concat(theme['input-color-default'], ";\n        border: ").concat(theme['border-width-default'], " ").concat(theme['border-style-solid'], " ").concat(status ? theme[statusColor] : theme['input-border-color-default'], ";\n      ");

    case 'active':
      return "\n        background-color: ".concat(theme['background-color-primary'], ";\n        color: ").concat(theme['input-color-default'], ";\n        border: ").concat(theme['border-width-default'], " ").concat(theme['border-style-solid'], " ").concat(theme['input-border-color-focus'], ";\n      ");

    case 'focus':
      return "\n        background-color: ".concat(theme['background-color-primary'], ";\n        color: ").concat(theme['input-color-default'], ";\n        border: ").concat(theme['border-width-default'], " ").concat(theme['border-style-solid'], " ").concat(theme['input-border-color-focus'], ";\n      ");

    default:
      return "\n        background-color: ".concat(theme['background-color-primary'], ";\n        color: ").concat(theme['input-color-default'], ";\n        border: ").concat(theme['border-width-default'], " ").concat(theme['border-style-solid'], " ").concat(status ? theme[statusColor] : theme['input-border-color-default'], ";\n      ");
  }
}
/**
 * Function which returns the TextInput styles based on the size
 * @param {string} size - string to accept the size of the TextInput
 */


function getInputSizeStyles(size, theme) {
  if (size === 'small') {
    return "\n      height: ".concat(theme['controls-size-small'], ";\n      font-size: ").concat(theme['text-size-m'], ";\n      line-height: ").concat(theme['line-height-l'], ";\n      font-weight: ").concat(theme['text-weight-regular'], ";\n      font-family: ").concat(theme['text-family-default'], ";\n    ");
  }

  return "\n      height: ".concat(theme['controls-size-default'], ";\n      font-size: ").concat(theme['text-size-m'], ";\n      line-height: ").concat(theme['line-height-xxl'], ";\n      font-weight: ").concat(theme['text-weight-regular'], ";\n      font-family: ").concat(theme['text-family-default'], ";\n    ");
}
/**
 * Function which returns the TextInput padding styles based on the size
 * @param {string} size - string to accept the size of the TextInput
 */


function getInputPaddingStyles(size, theme) {
  if (size === 'small') {
    return "\n        padding: ".concat(theme['spacing-s'], " ").concat(theme['spacing-zero'], " ").concat(theme['spacing-s'], " ").concat(theme['spacing-s'], ";\n\n        input {\n          padding-right: ").concat(theme['spacing-m'], ";\n        }\n      ");
  }

  return "\n      padding: ".concat(theme['spacing-s'], " ").concat(theme['spacing-zero'], " ").concat(theme['spacing-s'], " ").concat(theme['spacing-m'], ";\n\n      input {\n        padding-right: ").concat(theme['spacing-s'], ";\n      }\n    ");
}
/**
 * Function which returns the TextInput padding styles for functionality icons like password or clear input button
 * @param {string} size - string to accept the size of the TextInput
 */


function getInputFunctionalityIconStyles(size, theme) {
  if (size === 'small') {
    return "\n    & .input-functionality-icon {\n      display: flex;\n      height: ".concat(theme['size-s'], ";\n      width: ").concat(theme['size-s'], ";\n      margin: ").concat(theme['spacing-xs'], " ").concat(theme['spacing-xs'], " ").concat(theme['spacing-xs'], " ").concat(theme['spacing-zero'], ";\n\n      &:hover, &:active, &:focus {\n        background: none;\n      }\n    }\n    ");
  }

  return "\n    & .input-functionality-icon {\n      display: flex;\n      height: ".concat(theme['size-s'], ";\n      width: ").concat(theme['size-s'], ";\n      margin: ").concat(theme['spacing-xs'], " ").concat(theme['spacing-xs'], " ").concat(theme['spacing-xs'], " ").concat(theme['spacing-zero'], ";\n    }\n  ");
}
/**
 * Function which returns the color styles for validation message for the TextInput
 * @param {string} type - string to accept the validation status of the TextInput
 */


function getValidationStatusMessageStyles(type, theme) {
  var validationColor = "content-color-".concat(type);
  return "color: ".concat(theme[validationColor]);
}
/**
 * A function which renders the icons inside the input. It renders the following components:-
 * (i) Button with eye icon for password type input toggle
 * (ii) Button with clear icon for clearable inputs
 */

/* eslint-disable react/prop-types */


function renderInputIcons(_ref) {
  var type = _ref.type,
      isPasswordVisible = _ref.isPasswordVisible,
      handleTogglePasswordVisibility = _ref.handleTogglePasswordVisibility,
      handleOnClear = _ref.handleOnClear,
      onClear = _ref.onClear,
      value = _ref.value,
      size = _ref.size,
      isDisabled = _ref.isDisabled;
  return /*#__PURE__*/React.createElement(Flex, {
    gap: "spacing-xs"
  }, type === 'password' && /*#__PURE__*/React.createElement(StyledInputFunctionalityIcon, {
    size: size
  }, /*#__PURE__*/React.createElement(Button, {
    type: "tertiary",
    isDisabled: isDisabled,
    icon: isPasswordVisible ? 'icon-action-hide-stroke' : 'icon-action-view-stroke',
    onClick: handleTogglePasswordVisibility,
    className: "input-functionality-icon",
    size: size,
    tooltip: /*#__PURE__*/React.createElement(Tooltip, {
      content: isPasswordVisible ? 'Hide password' : 'Show password',
      placement: "top"
    })
  })), !!value && onClear && ['search', 'text'].includes(type) && /*#__PURE__*/React.createElement(StyledInputFunctionalityIcon, {
    size: size
  }, /*#__PURE__*/React.createElement(Button, {
    isDisabled: isDisabled,
    type: "tertiary",
    size: size,
    icon: "icon-action-clear-stroke",
    onClick: handleOnClear,
    className: "input-functionality-icon",
    tooltip: /*#__PURE__*/React.createElement(Tooltip, {
      content: "Clear input",
      placement: "top"
    })
  })));
}
/**
 * Function to render the TextInput prefix contents
 * Note:- prefix feature is under development and is not ready to be used as a prop.
 * Added the implementation only for search input functionality for now.
 * This definition is going to be updated in the future releases.
 * @param {any} prefix - The prop which accepts the prefix. Can be either a string or a react JSX.
 * @param {string} type - TextInput type
 * @param {string} size - TextInput size
 */


function getTextInputPrefix(prefix, type, size) {
  if (type === 'search') {
    return /*#__PURE__*/React.createElement(Icon, {
      name: "icon-action-search-stroke",
      color: "content-color-secondary",
      size: size === 'small' ? 'small' : 'large'
    });
  }

  return null;
}
/* eslint-enable react/prop-types */


var StyledInputFunctionalityIcon = styled.div.withConfig({
  displayName: "TextInput__StyledInputFunctionalityIcon",
  componentId: "sc-1cf8yr2-0"
})(["display:inline-flex;", ""], function (props) {
  return getInputFunctionalityIconStyles(props.size, props.theme);
});
var StyledTextInputContainer = styled.div.withConfig({
  displayName: "TextInput__StyledTextInputContainer",
  componentId: "sc-1cf8yr2-1"
})(["display:flex;flex-direction:column;width:100%;"]);
var StyledTextInputItem = styled.div.withConfig({
  displayName: "TextInput__StyledTextInputItem",
  componentId: "sc-1cf8yr2-2"
})(["box-sizing:border-box;display:flex;justify-content:space-between;align-items:center;transition:border-color 0.2s ease-in-out,box-shadow 0.2s ease-in-out;border-radius:", ";", " ", ";width:", ";", " &:hover{", ";}&:focus-within{", ";}", " ", ";", ""], function (props) {
  return props.theme['border-radius-default'];
}, function (props) {
  return getInputSizeStyles(props.size, props.theme);
}, function (props) {
  return getInputStyles('default', props.validationStatus, props.theme);
}, function (props) {
  return props.width;
}, function (props) {
  return getInputPaddingStyles(props.size, props.theme);
}, function (props) {
  return !props.isDisabled && getInputStyles('hover', props.validationStatus, props.theme);
}, function (props) {
  return !props.isDisabled && getInputStyles('focus', props.validationStatus, props.theme);
}, function (props) {
  return props.isDisabled && " background: ".concat(props.theme['input-background-color-disabled'], ";\n      border: ").concat(props.theme['border-width-default'], " ").concat(props.theme['border-style-solid'], " ").concat(props.theme['border-color-strong'], ";\n      color: ").concat(props.theme['content-color-tertiary'], ";\n      cursor: not-allowed;\n    ");
}, function (props) {
  return props.interactionState === 'focus' || props.interactionState === 'active' ? "\n      box-shadow: 0 0 0 2px ".concat(props.theme['input-shadow-focus'], "\n      ") : null;
}, function (props) {
  return (props.label || props.helperText) && props.isLabelHidden === false ? "margin-top: ".concat(props.theme['spacing-xs'], ";") : undefined;
});
var StyledInput = styled.input.withConfig({
  displayName: "TextInput__StyledInput",
  componentId: "sc-1cf8yr2-3"
})(["box-sizing:border-box;width:100%;outline:none;border-color:transparent;appearance:none;padding:", ";background:transparent;color:inherit;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;", " &::-webkit-search-cancel-button{display:none;}", ";"], function (props) {
  return props.theme['spacing-zero'];
}, function (props) {
  return getInputSizeStyles(props.size, props.theme);
}, mixins.includeDisabledState());
var StyledValidationMessage = styled.p.withConfig({
  displayName: "TextInput__StyledValidationMessage",
  componentId: "sc-1cf8yr2-4"
})(["display:flex;align-items:center;", ";font-size:", ";line-height:", ";margin:", " ", " ", " ", ";.validation-message-icon{margin-right:", ";}"], function (props) {
  return getValidationStatusMessageStyles(props.type, props.theme);
}, function (props) {
  return props.theme['text-size-s'];
}, function (props) {
  return props.theme['line-height-s'];
}, function (props) {
  return props.theme['spacing-xs'];
}, function (props) {
  return props.theme['spacing-zero'];
}, function (props) {
  return props.theme['spacing-zero'];
}, function (props) {
  return props.theme['spacing-zero'];
}, function (props) {
  return props.theme['spacing-xs'];
});
var StyledTextInputActionableContainer = styled.span.withConfig({
  displayName: "TextInput__StyledTextInputActionableContainer",
  componentId: "sc-1cf8yr2-5"
})(["cursor:default;user-select:none;width:max-content;"]);
var StyledPrefixContainer = styled.div.withConfig({
  displayName: "TextInput__StyledPrefixContainer",
  componentId: "sc-1cf8yr2-6"
})(["display:flex;cursor:text;padding-right:", ";"], function (props) {
  return props.theme['spacing-s'];
});
var TextInput = /*#__PURE__*/React.forwardRef(function TextInput(props, ref) {
  var type = props.type,
      placeholder = props.placeholder,
      value = props.value,
      onChange = props.onChange,
      onBlur = props.onBlur,
      onFocus = props.onFocus,
      onKeyDown = props.onKeyDown,
      onClear = props.onClear,
      min = props.min,
      size = props.size,
      max = props.max,
      maxLength = props.maxLength,
      validationStatus = props.validationStatus,
      isDisabled = props.isDisabled,
      name = props.name,
      className = props.className,
      helperText = props.helperText,
      validationMessage = props.validationMessage,
      id = props.id,
      label = props.label,
      width = props.width,
      prefix = props.prefix;

  var _useState = useState('default'),
      _useState2 = _slicedToArray(_useState, 2),
      interactionState = _useState2[0],
      setInteractionState = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isPasswordVisible = _useState4[0],
      setPasswordVisibility = _useState4[1];

  var inputRef = ref || /*#__PURE__*/React.createRef();

  var handleTogglePasswordVisibility = function handleTogglePasswordVisibility() {
    // eslint-disable-next-line no-shadow
    setPasswordVisibility(function (isPasswordVisible) {
      return !isPasswordVisible;
    }); // focus the input field on clicking the password toggle button

    inputRef.current.focus();
  };

  var handleOnClear = function handleOnClear() {
    // eslint-disable-next-line no-shadow
    if (onClear) {
      onClear();
    } // focus the input field on clicking the password toggle button


    inputRef.current.focus();
  };

  var handleOnMouseDown = function handleOnMouseDown() {
    setInteractionState('active');
  };

  var handleChange = function handleChange(event) {
    // stopping unnecessary Fn calls when checkbox is disabled
    if (!isDisabled) {
      if (onChange) onChange(event);
    }
  };

  var handleLabelClick = function handleLabelClick() {
    if (!isDisabled) {
      inputRef.current.focus();
    }
  };

  var handleOnFocus = function handleOnFocus(event) {
    if (!isDisabled) {
      setInteractionState('focus');
      if (onFocus) onFocus(event);
    }
  };

  var handleOnKeyDown = function handleOnKeyDown(event) {
    if (!isDisabled) {
      if (onKeyDown) onKeyDown(event);
    }
  };

  var handleOnBlur = function handleOnBlur(event) {
    if (!isDisabled) {
      setInteractionState('default');
      if (onBlur) onBlur(event);
    }
  };

  var renderLabel = function renderLabel(labelComp, idVal) {
    if (labelComp && labelComp.type === Label) {
      return /*#__PURE__*/React.cloneElement(labelComp, {
        type: 'primary',
        htmlFor: idVal
      });
    }

    return null;
  };

  return /*#__PURE__*/React.createElement(StyledTextInputContainer, null, /*#__PURE__*/React.createElement(StyledTextInputActionableContainer, {
    onClick: handleLabelClick
  }, renderLabel(label, id)), helperText && /*#__PURE__*/React.createElement(Text, {
    type: "_input-meta-text"
  }, helperText), /*#__PURE__*/React.createElement(StyledTextInputItem, {
    interactionState: interactionState,
    isDisabled: isDisabled,
    size: size,
    validationStatus: validationStatus,
    className: className,
    label: label,
    helperText: helperText,
    isLabelHidden: label && label.props && label.props.isHidden,
    width: width
  }, getTextInputPrefix(prefix, type, size) && /*#__PURE__*/React.createElement(StyledPrefixContainer, {
    onClick: handleLabelClick
  }, getTextInputPrefix(prefix, type, size)), /*#__PURE__*/React.createElement(StyledInput, {
    type: type === 'password' && isPasswordVisible ? 'text' : type,
    placeholder: placeholder,
    value: value,
    onBlur: handleOnBlur,
    onFocus: handleOnFocus,
    onChange: handleChange,
    onKeyDown: handleOnKeyDown,
    onMouseDown: handleOnMouseDown,
    disabled: isDisabled,
    ref: inputRef,
    min: min,
    max: max,
    maxLength: maxLength,
    size: size,
    name: name,
    id: id
  }), renderInputIcons({
    type: type,
    onClear: onClear,
    isPasswordVisible: isPasswordVisible,
    handleTogglePasswordVisibility: handleTogglePasswordVisibility,
    handleOnClear: handleOnClear,
    inputRef: inputRef,
    value: value,
    size: size,
    isDisabled: isDisabled
  })), validationStatus && validationMessage && /*#__PURE__*/React.createElement(StyledValidationMessage, {
    type: validationStatus
  }, /*#__PURE__*/React.createElement(Icon, {
    color: "content-color-".concat(validationStatus),
    className: "validation-message-icon",
    name: "icon-state-".concat(validationStatus, "-stroke-small"),
    size: "small"
  }), validationMessage));
});
TextInput.displayName = 'TextInput';
export default TextInput;
TextInput.defaultProps = {
  type: 'text',
  size: 'medium',
  value: '',
  placeholder: '',
  isDisabled: false,
  onClear: null,
  onFocus: null,
  onBlur: null,
  onKeyDown: null,
  min: undefined,
  max: undefined,
  maxLength: undefined,
  validationStatus: undefined,
  name: undefined,
  className: undefined,
  helperText: '',
  validationMessage: '',
  id: undefined,
  label: '',
  width: '100%',
  prefix: undefined
};
TextInput.propTypes = {
  type: PropTypes.oneOf(TEXTINPUT_TYPE_VARIANTS),
  size: PropTypes.oneOf(TEXTINPUT_SIZE_VARIANTS),
  width: PropTypes.string,
  value: PropTypes.string,
  onChange: PropTypes.func.isRequired,
  onKeyDown: PropTypes.func,
  placeholder: PropTypes.string,
  isDisabled: PropTypes.bool,
  helperText: PropTypes.string,
  validationMessage: PropTypes.string,
  onClear: function onClear(_ref2) {
    var _onClear = _ref2.onClear,
        type = _ref2.type;

    if (_onClear) {
      if (typeof _onClear !== 'function') {
        return new Error("\n        TextInput: onClear prop should be a function\n      ");
      }

      if (type !== 'text') {
        return new Error("\n        TextInput: onClear prop should only be called with TextInputs of type text\n      ");
      }
    }

    return null;
  },
  onFocus: PropTypes.func,
  onBlur: PropTypes.func,
  min: function min(_ref3) {
    var _min = _ref3.min,
        type = _ref3.type;

    if (_min) {
      if (type !== 'number') {
        return new Error("TextInput: min prop should only be used with number type TextInput");
      }

      if (typeof _min !== 'number') {
        return new Error("TextInput: min prop should be a number");
      }
    }

    return null;
  },
  max: function max(_ref4) {
    var _max = _ref4.max,
        type = _ref4.type;

    if (_max) {
      if (type !== 'number') {
        return new Error("TextInput: max prop should only be used with number type TextInput");
      }

      if (typeof _max !== 'number') {
        return new Error("TextInput: max prop should be a number");
      }
    }

    return null;
  },
  maxLength: PropTypes.number,
  validationStatus: function validationStatus(_ref5) {
    var _validationStatus = _ref5.validationStatus;

    if (_validationStatus && VALIDATION_STATUS_VARIANTS.indexOf(_validationStatus) === -1) {
      return new Error("\n      Textinput: Invalid prop for validationStatus: expected one of \"error\", \"success\" or \"warning\"\n      ");
    }

    return null;
  },
  name: PropTypes.string,
  className: PropTypes.string,
  id: PropTypes.string,
  label: function label(props) {
    var label = props.label;

    if (label) {
      if (label.type !== Label) return new Error('TextInput: label prop only accepts Aether Label component.');
      var labelType = label.props && label.props.type;
      if (labelType !== 'primary') return new Error('TextInput: label prop only accepts Label type primary.');
    }

    return null;
  },
  prefix: PropTypes.element
};