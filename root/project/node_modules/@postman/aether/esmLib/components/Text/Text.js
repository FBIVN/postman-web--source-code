function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import React from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import TextLink, { TEXT_LINK_VARIANTS } from './TextLink';
import { globals, aliases } from '../../design-tokens/tokens';
import Paragraph from './Paragraph';
import Strong from './Strong';
import Code from './Code';
import Small from './Small';
import Kbd from './Kbd';
import { wrapWithTooltip, isTextTruncatable } from '../../utils/common/index'; // listing all text type variants

export var TEXT_VARIANTS = ['body-large', 'body-medium', 'body-small', 'link-default', 'link-primary', 'link-subtle', 'link-button', 'link-button-primary', 'link-button-outline', 'para', 'lead', 'strong', 'code', 'small', 'kbd', // This is only for internal usage, not to be used anywhere outside of this repository.
'_input-meta-text'];
var TEXT_TRUNCATION_VARIANTS = ['body-medium', 'body-large', 'body-small', 'para', 'lead', 'small'];

function getTextStyles(type, theme) {
  switch (type) {
    case 'body-large':
      return "\n        font-size: ".concat(theme['text-size-l'], ";\n        line-height: ").concat(theme['line-height-l'], ";\n        font-weight: ").concat(theme['text-weight-regular'], ";\n        font-family: ").concat(theme['text-family-default'], ";\n       ");

    case 'body-medium':
      return "\n        font-size: ".concat(theme['text-size-m'], ";\n        line-height: ").concat(theme['line-height-m'], ";\n        font-weight: ").concat(theme['text-weight-regular'], ";\n        font-family: ").concat(theme['text-family-default'], ";\n       ");

    case 'body-small':
      return "\n        font-size: ".concat(theme['text-size-s'], ";\n        line-height: ").concat(theme['line-height-s'], ";\n        font-weight: ").concat(theme['text-weight-regular'], ";\n        font-family: ").concat(theme['text-family-default'], ";\n       ");

    default:
      return "\n        font-size: ".concat(theme['text-size-m'], ";\n        line-height: 1.6;\n        font-weight: ").concat(theme['text-weight-regular'], ";\n        font-family: ").concat(theme['text-family-default'], ";\n      ");
  }
} // Listing all Paragraph variants


var paragraphVariants = ['para', 'lead']; // valid colors of text components

var colorVariants = [''].concat(_toConsumableArray(Object.keys(globals.colors)), _toConsumableArray(Object.keys(aliases.light.colors)), _toConsumableArray(Object.keys(aliases.light.content)), ['header-color-content']);
/**
 * Function which applies the typography styles to the Text component
 * We have provided a prop to Text component
 * i.e. typographyStyle which accepts typography properties
 * Eg:-  {fontWeight: number, lineHeight: string, fontFamily: string, fontSize: string}
 * This prop is passed as an argument to this function
 * which then returns the required typography styles
 *
 * @param {Object} typographyObject - This argument accepts an object of typography styles
 *
 */

function getCustomTypographyStyles(typographyObject, theme) {
  if (!typographyObject) return null;
  var fontFamilyVariants = ['text-family-default', 'text-family-code'];
  var fontFamily = 'text-family-default';

  if (typographyObject.fontFamily && fontFamilyVariants.includes(typographyObject.fontFamily)) {
    fontFamily = typographyObject.fontFamily;
  }

  return "\n    font-size: ".concat(theme[typographyObject.fontSize], ";\n    font-weight : ").concat(theme[typographyObject.fontWeight], ";\n    line-height: ").concat(theme[typographyObject.lineHeight], ";\n    font-family: ").concat(theme[fontFamily], ";\n  ");
}
/**
 * Function to get truncation related styles for the typography components
 * @param {boolean} isTruncated - determines whether single line truncation is enabled
 * @param {number} maxLines - enables multi-line truncation
 * @returns a string of css styles.
 */


function getTextTruncationStyles(isTruncated, maxLines) {
  // single line truncation styles
  // also adding styles on top of truncation styles to prevent tooltip coming on truncated elements on Safari.
  var isTruncatedStyles = "\n      display: inline-block;\n      text-overflow: ellipsis;\n      overflow: hidden;\n      white-space: nowrap;\n      max-width: 100%;\n\n      &::after {\n        content: ' ';\n        display: block;\n        width: 0;\n        height: 0;\n        line-height: 0;\n      }\n    "; // multi-line truncation styles

  var maxLinesStyles = "\n    display: -webkit-box;\n    -webkit-line-clamp: ".concat(maxLines, ";\n    -webkit-box-orient: vertical;  \n    overflow: hidden;\n    ");
  return "\n    ".concat(isTruncated ? isTruncatedStyles : '', "\n    ").concat(maxLines ? maxLinesStyles : '', "\n    ");
}
/**
 * This component renders user facing text.
 *
 * @param {Object} props - Object of props
 * @param {String=''} props.children - specifies the text to display
 * @param {String} props.type - specifies the variant of the Text component. Based on the value
 * of this prop, a combination of typography tokens is integrated.
 *
 */


var TextContainer = styled.span.withConfig({
  displayName: "Text__TextContainer",
  componentId: "sc-1ddv9v9-0"
})(["", ";", ";", ";", " word-break:", ";"], function (props) {
  return getTextStyles(props.type, props.theme);
}, function (props) {
  return getCustomTypographyStyles(props.typographyStyle, props.theme);
}, function (props) {
  return props.color && "color: ".concat(props.theme[props.color], ";");
}, function (props) {
  return getTextTruncationStyles(props.isTruncated, props.maxLines);
}, function (props) {
  return props.wordBreak;
});
var StyledInputMetaText = styled.p.withConfig({
  displayName: "Text__StyledInputMetaText",
  componentId: "sc-1ddv9v9-1"
})(["color:", ";font-size:", ";line-height:", ";margin:", ";"], function (props) {
  return props.theme['content-color-secondary'];
}, function (props) {
  return props.theme['text-size-s'];
}, function (props) {
  return props.theme['line-height-s'];
}, function (props) {
  return props.theme['spacing-zero'];
});
export default function Text(props) {
  var children = props.children,
      type = props.type,
      text = props.text,
      color = props.color,
      typographyStyle = props.typographyStyle,
      className = props.className,
      isExternal = props.isExternal,
      hasBottomSpacing = props.hasBottomSpacing,
      isTruncated = props.isTruncated,
      maxLines = props.maxLines,
      maxWidth = props.maxWidth,
      tooltip = props.tooltip,
      _wordBreak = props._wordBreak,
      __renderAs = props.__renderAs;

  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      isTooltipVisible = _React$useState2[0],
      setTooltipVisible = _React$useState2[1];

  if (TEXT_LINK_VARIANTS.indexOf(type) >= 0) {
    return /*#__PURE__*/React.createElement(TextLink, {
      type: type,
      className: className,
      isExternal: isExternal
    }, children || text);
  }

  if (paragraphVariants.indexOf(type) >= 0) {
    return /*#__PURE__*/React.createElement(Paragraph, {
      className: className,
      type: type,
      hasBottomSpacing: hasBottomSpacing,
      color: color || 'content-color-secondary',
      isTruncated: isTruncated,
      maxLines: maxLines,
      maxWidth: maxWidth,
      tooltip: tooltip
    }, children || text);
  }

  if (type === 'strong') {
    return /*#__PURE__*/React.createElement(Strong, null, children || text);
  }

  if (type === 'code') {
    return /*#__PURE__*/React.createElement(Code, null, children || text);
  }

  if (type === 'small') {
    return /*#__PURE__*/React.createElement(Small, {
      isTruncated: isTruncated,
      maxLines: maxLines,
      tooltip: tooltip
    }, children || text);
  }

  if (type === 'kbd') {
    return /*#__PURE__*/React.createElement(Kbd, null, children || text);
  }
  /* This type is only for internal purposes since these styles are bound to be used in almost all form elements
     like TextInput, TextArea, Dropdowns etc.
     This variant is used internally in this project, not to be consumed in the postman-app or dashboard.
     These styles are not the same as para and use different typography properties only for the helperText and validationMessage use case for form elements only.
     This way we can keep these common styles and consume them from a single place, and also know if any new exceptions come up.
  */


  if (type === '_input-meta-text') {
    return /*#__PURE__*/React.createElement(StyledInputMetaText, null, children || text);
  }

  var jsx = /*#__PURE__*/React.createElement(TextContainer, {
    type: type,
    color: color,
    as: __renderAs,
    wordBreak: _wordBreak,
    tabIndex: __renderAs ? 0 : undefined,
    typographyStyle: typographyStyle,
    className: className,
    isTruncated: isTruncated,
    maxLines: maxLines,
    onMouseEnter: function onMouseEnter(e) {
      if (e.target.scrollWidth > e.target.offsetWidth) {
        setTooltipVisible(true);
      } else {
        setTooltipVisible(false);
      }
    }
  }, children || text);
  return isTooltipVisible && isTextTruncatable(props) ? wrapWithTooltip(jsx, tooltip || children || text) : jsx;
}
Text.defaultProps = {
  // deprecated, will be removed soon
  text: '',
  type: '',
  color: '',
  className: '',
  isExternal: false,
  typographyStyle: null,
  hasBottomSpacing: false,
  isTruncated: false,
  maxLines: undefined,
  // This prop is only internal and subjected to be deprecated / updated in the future. Not to be used in the app.
  maxWidth: '60ch',
  tooltip: '',
  __renderAs: undefined,
  _wordBreak: 'normal'
};
Text.propTypes = {
  // deprecated, will be removed soon
  text: function text(props) {
    var text = props.text,
        children = props.children;

    if (!children && text) {
      if (typeof text !== 'string') {
        return new Error('text (deprecated property): Expected a string value.');
      }

      return new Error('text: Aether v.0.2.5 onwards we are providing children support for Text component and deprecating the text prop (will be removed soon). It is recommended to provide values as children to the Text component.');
    }

    return null;
  },
  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]).isRequired,
  className: PropTypes.string,
  color: function color(props) {
    var type = props.type,
        color = props.color; // color prop is invalid when link-* type variants

    if (color && TEXT_LINK_VARIANTS.indexOf(type) >= 0) {
      return new Error('color: color property is not applicable to link type text variants. ');
    } // color prop is not applicable for strong, code, small and kbd text variants


    if (color && ['strong', 'code', 'small', 'kbd'].indexOf(type) >= 0) {
      return new Error('color: color property is not applicable to strong, code, small and kbd text variants ');
    } // valid color prop checks


    if (color && colorVariants.indexOf(color) < 0) {
      return new Error("color: invalid color value provided, the value must be from ".concat(_toConsumableArray(colorVariants)));
    }

    return null;
  },

  /**
   * Use this props to apply custom typography properties to the Text component.
   * You can set values for font-family, font-size, font-weight and line-height.
   * But these values must be from typography tokens.
   * You can't use both type and typographyStyle property at once.
   */
  typographyStyle: PropTypes.shape({
    fontSize: PropTypes.oneOf(['text-size-xs', 'text-size-s', 'text-size-m', 'text-size-l', 'text-size-xl', 'text-size-xxl', 'text-size-xxxl']).isRequired,
    fontWeight: PropTypes.oneOf(['text-weight-regular', 'text-weight-medium', 'text-weight-bold']).isRequired,
    lineHeight: PropTypes.oneOf(['line-height-xs', 'line-height-s', 'line-height-m', 'line-height-l', 'line-height-xl', 'line-height-xxl', 'line-height-xxxl']).isRequired,
    fontFamily: PropTypes.oneOf(['text-family-default', 'text-family-code'])
  }),

  /** Use this prop to define the text variant. */
  type: function type(props, _key, componentName) {
    var type = props.type,
        typographyStyle = props.typographyStyle;

    if (type && !typographyStyle) {
      if (!TEXT_VARIANTS.includes(type)) {
        return new Error("Invalid value supplied to the type prop of ".concat(componentName, " component. Expected one of ").concat(TEXT_VARIANTS));
      }

      return null;
    }

    if (typographyStyle && type) {
      return new Error('Text: You cannot use both typographyStyle and type props at once for Text component');
    }

    return null;
  },
  isExternal: function isExternal(props) {
    var type = props.type,
        isExternal = props.isExternal;

    if (isExternal && (!type || type && TEXT_LINK_VARIANTS.indexOf(type) < 0)) {
      return new Error('isExternal: isExternal is only applicable for type variants "link-default", "link-primary", "link-subtle"');
    }

    return null;
  },
  hasBottomSpacing: function hasBottomSpacing(props) {
    var hasBottomSpacing = props.hasBottomSpacing,
        type = props.type;

    if (hasBottomSpacing && !(paragraphVariants.indexOf(type) >= 0)) {
      return new Error('Text: hasBottomSpacing is only applicable with text variants "para" or "lead"');
    }

    return null;
  },
  isTruncated: function isTruncated(_ref) {
    var _isTruncated = _ref.isTruncated,
        maxLines = _ref.maxLines,
        type = _ref.type;

    if (typeof _isTruncated !== 'boolean') {
      return new Error('Text: expected a boolean value for isTruncated prop');
    }

    if (type && _isTruncated && !TEXT_TRUNCATION_VARIANTS.includes(type)) {
      return new Error("Text: Text truncation props like maxLines and isTruncated can only be used with ".concat(TEXT_TRUNCATION_VARIANTS));
    }

    if (_isTruncated && maxLines) {
      return new Error('Text: maxLines should not be used together with isTruncated prop');
    }

    return null;
  },
  _wordBreak: PropTypes.oneOf(['normal', 'break-all', 'keep-all', 'break-word', 'inherit', 'initial', 'revert', 'unset']),
  maxLines: PropTypes.number,
  // This prop is only internal and subjected to be deprecated / updated in the future. Not to be used in the app.
  maxWidth: PropTypes.string,
  tooltip: function tooltip(props) {
    var tooltip = props.tooltip,
        isTruncated = props.isTruncated,
        maxLines = props.maxLines,
        type = props.type;

    if (typeof tooltip !== 'string') {
      return new Error('Text: tooltip prop should only have a string value.');
    }

    if (tooltip && type && !TEXT_TRUNCATION_VARIANTS.includes(type)) {
      return new Error('Text: tooltip prop cannot be used with current value supplied to the type prop');
    }

    if (tooltip && (!isTruncated || maxLines)) {
      return new Error('Text: tooltip prop should only be used when using single-line truncation by using isTruncated prop.');
    }

    return null;
  },
  __renderAs: PropTypes.string
};