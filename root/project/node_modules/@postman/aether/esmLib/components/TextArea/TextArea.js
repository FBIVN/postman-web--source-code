import React from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';
import mixins from '../../utils/common/mixins';
import Label from '../Label/Label';
import Icon from '../Icon/Icon';
import Text from '../Text/Text';
var VALIDATION_STATUS_VARIANTS = ['error', 'warning', 'success'];
/**
 * Function which returns the TextArea styles based on the current interaction state
 * @param {string} interactionState - The current interaction state of the TextArea
 * @param {string} status - Validation status of the TextArea component, possible values are error, warning or success
 */

function getInputStyles(interactionState, status, theme) {
  var statusColor = status ? "input-border-color-".concat(status) : '';

  switch (interactionState) {
    case 'hover':
      return "\n          background-color: ".concat(theme['background-color-primary'], ";\n          color: ").concat(theme['input-color-default'], ";\n          border: ").concat(theme['border-width-default'], " ").concat(theme['border-style-solid'], " ").concat(status ? theme[statusColor] : theme['input-border-color-default'], ";\n        ");

    case 'active':
      return "\n          background-color: ".concat(theme['background-color-primary'], ";\n          color: ").concat(theme['input-color-default'], ";\n          border: ").concat(theme['border-width-default'], " ").concat(theme['border-style-solid'], " ").concat(theme['input-border-color-focus'], ";\n      box-shadow: 0 0 0 2px ").concat(theme['input-shadow-focus'], ";\n        ");

    case 'focus':
      return "\n          background-color: ".concat(theme['background-color-primary'], ";\n          color: ").concat(theme['input-color-default'], ";\n          border: ").concat(theme['border-width-default'], " ").concat(theme['border-style-solid'], " ").concat(theme['input-border-color-focus'], ";\n      box-shadow: 0 0 0 2px ").concat(theme['input-shadow-focus'], ";\n        ");

    default:
      return "\n          background-color: ".concat(theme['background-color-primary'], ";\n          color: ").concat(theme['input-color-default'], ";\n          border: ").concat(theme['border-width-default'], " ").concat(theme['border-style-solid'], " ").concat(status ? theme[statusColor] : theme['input-border-color-default'], ";\n        ");
  }
}
/**
 * Function which returns the color styles for validation message for the TextArea
 * @param {string} type - string to accept the validation status of the TextArea
 */


function getValidationStatusMessageStyles(type, theme) {
  var validationColor = "content-color-".concat(type);
  return "color: ".concat(theme[validationColor]);
}
/**
 * Function which returns the typography and spacing styles for TextArea component
 */


function getTextAreaSizeStyles(theme) {
  return "\n    padding: ".concat(theme['spacing-s'], " ").concat(theme['spacing-m'], ";\n    font-size: ").concat(theme['text-size-m'], ";\n    line-height: ").concat(theme['line-height-m'], ";\n    font-weight: ").concat(theme['text-weight-regular'], ";\n    font-family: ").concat(theme['text-family-default'], ";\n    min-height: 36px;\n    max-height: 400px;\n    ");
}

var StyledTextAreaContainer = styled.div.withConfig({
  displayName: "TextArea__StyledTextAreaContainer",
  componentId: "sc-1rbmsvb-0"
})(["display:flex;flex-direction:column;width:100%;"]);
var StyledTextArea = styled.textarea.withConfig({
  displayName: "TextArea__StyledTextArea",
  componentId: "sc-1rbmsvb-1"
})(["", " ", " min-width:100%;box-sizing:border-box;outline:none;transition:border-color 0.2s ease-in-out,box-shadow 0.2s ease-in-out;border-radius:", ";", ";&:hover{", ";}&:active{", ";}&:focus-within{", ";}", " ", " ", ";"], function (props) {
  return getTextAreaSizeStyles(props.theme);
}, function (props) {
  return !props.isResizable ? 'resize: none;' : 'resize: vertical;';
}, function (props) {
  return props.theme['border-radius-default'];
}, function (props) {
  return getInputStyles('default', props.validationStatus, props.theme);
}, function (props) {
  return !props.disabled && getInputStyles('hover', props.validationStatus, props.theme);
}, function (props) {
  return !props.disabled && getInputStyles('active', props.validationStatus, props.theme);
}, function (props) {
  return !props.disabled && getInputStyles('focus', props.validationStatus, props.theme);
}, function (props) {
  return props.disabled && " background: ".concat(props.theme['input-background-color-disabled'], ";\n      border: ").concat(props.theme['border-width-default'], " ").concat(props.theme['border-style-solid'], " ").concat(props.theme['border-color-strong'], ";\n      color: ").concat(props.theme['content-color-tertiary'], ";\n      cursor: not-allowed;\n    ");
}, function (props) {
  return (props.label || props.helperText) && props.isLabelHidden === false ? "margin-top: ".concat(props.theme['spacing-xs'], ";") : undefined;
}, mixins.includeDisabledState());
var StyledValidationMessage = styled.p.withConfig({
  displayName: "TextArea__StyledValidationMessage",
  componentId: "sc-1rbmsvb-2"
})(["display:flex;align-items:center;", ";font-size:", ";line-height:", ";margin:", " ", " ", " ", ";.validation-message-icon{margin-right:", ";}"], function (props) {
  return getValidationStatusMessageStyles(props.type, props.theme);
}, function (props) {
  return props.theme['text-size-s'];
}, function (props) {
  return props.theme['line-height-s'];
}, function (props) {
  return props.theme['spacing-xs'];
}, function (props) {
  return props.theme['spacing-zero'];
}, function (props) {
  return props.theme['spacing-zero'];
}, function (props) {
  return props.theme['spacing-zero'];
}, function (props) {
  return props.theme['spacing-xs'];
});
var StyledTextAreaActionableContainer = styled.span.withConfig({
  displayName: "TextArea__StyledTextAreaActionableContainer",
  componentId: "sc-1rbmsvb-3"
})(["cursor:default;user-select:none;width:max-content;"]);

function TextArea(props) {
  var value = props.value,
      placeholder = props.placeholder,
      rows = props.rows,
      className = props.className,
      onChange = props.onChange,
      onFocus = props.onFocus,
      onBlur = props.onBlur,
      isDisabled = props.isDisabled,
      validationStatus = props.validationStatus,
      validationMessage = props.validationMessage,
      isResizable = props.isResizable,
      name = props.name,
      innerRef = props.innerRef,
      helperText = props.helperText,
      label = props.label,
      id = props.id;
  var inputRef = innerRef || /*#__PURE__*/React.createRef();

  var handleChange = function handleChange(event) {
    if (!isDisabled) {
      if (onChange) onChange(event);
    }
  };

  var handleOnFocus = function handleOnFocus(event) {
    if (!isDisabled) {
      if (onFocus) onFocus(event);
    }
  };

  var handleLabelClick = function handleLabelClick() {
    if (!isDisabled) {
      inputRef.current.focus();
    }
  };

  var handleOnBlur = function handleOnBlur(event) {
    if (!isDisabled) {
      if (onBlur) onBlur(event);
    }
  };

  var renderLabel = function renderLabel(labelComp, idVal) {
    if (labelComp && labelComp.type === Label) {
      return /*#__PURE__*/React.cloneElement(labelComp, {
        type: 'primary',
        htmlFor: idVal
      });
    }

    return null;
  };

  return /*#__PURE__*/React.createElement(StyledTextAreaContainer, null, /*#__PURE__*/React.createElement(StyledTextAreaActionableContainer, {
    onClick: handleLabelClick
  }, renderLabel(label, id)), helperText && /*#__PURE__*/React.createElement(Text, {
    type: "_input-meta-text"
  }, helperText), /*#__PURE__*/React.createElement(StyledTextArea, {
    value: value,
    placeholder: placeholder,
    rows: rows,
    className: className,
    onFocus: handleOnFocus,
    onBlur: handleOnBlur,
    onChange: handleChange,
    disabled: isDisabled,
    validationStatus: validationStatus,
    isResizable: isResizable,
    ref: inputRef,
    name: name,
    id: id,
    label: label,
    helperText: helperText,
    isLabelHidden: label && label.props && label.props.isHidden
  }), validationStatus && validationMessage && /*#__PURE__*/React.createElement(StyledValidationMessage, {
    type: validationStatus
  }, /*#__PURE__*/React.createElement(Icon, {
    color: "content-color-".concat(validationStatus),
    className: "validation-message-icon",
    name: "icon-state-".concat(validationStatus, "-stroke-small"),
    size: "small"
  }), validationMessage));
}

export default /*#__PURE__*/React.forwardRef(function (props, ref) {
  /* eslint-disable react/prop-types */
  var value = props.value,
      placeholder = props.placeholder,
      rows = props.rows,
      className = props.className,
      onChange = props.onChange,
      onFocus = props.onFocus,
      onBlur = props.onBlur,
      isDisabled = props.isDisabled,
      validationStatus = props.validationStatus,
      validationMessage = props.validationMessage,
      isResizable = props.isResizable,
      name = props.name,
      helperText = props.helperText,
      label = props.label,
      fieldType = props.fieldType,
      id = props.id,
      infoText = props.infoText,
      isLabelHidden = props.isLabelHidden;
  return /*#__PURE__*/React.createElement(TextArea, {
    value: value,
    placeholder: placeholder,
    rows: rows || 3,
    className: className,
    onChange: onChange,
    onFocus: onFocus,
    onBlur: onBlur,
    isDisabled: isDisabled,
    validationStatus: validationStatus,
    validationMessage: validationMessage,
    isResizable: isResizable,
    name: name,
    innerRef: ref,
    helperText: helperText,
    label: label,
    fieldType: fieldType,
    id: id,
    infoText: infoText,
    isLabelHidden: isLabelHidden
  });
});
/* eslint-enable react/prop-types */

TextArea.defaultProps = {
  value: '',
  placeholder: '',
  isDisabled: false,
  onFocus: null,
  onBlur: null,
  className: undefined,
  validationStatus: undefined,
  isResizable: true,
  name: undefined,
  innerRef: undefined,
  rows: 3,
  validationMessage: '',
  helperText: '',
  label: '',
  id: undefined
};
TextArea.propTypes = {
  value: PropTypes.string,
  placeholder: PropTypes.string,
  isDisabled: PropTypes.bool,
  onChange: PropTypes.func.isRequired,
  onFocus: PropTypes.func,
  onBlur: PropTypes.func,
  className: PropTypes.string,
  validationStatus: function validationStatus(_ref) {
    var _validationStatus = _ref.validationStatus;

    if (_validationStatus && VALIDATION_STATUS_VARIANTS.indexOf(_validationStatus) === -1) {
      return new Error("\n      TextArea: Invalid prop for validationStatus: expected one of \"error\", \"success\" or \"warning\"\n      ");
    }

    return null;
  },
  validationMessage: PropTypes.string,
  helperText: PropTypes.string,
  rows: PropTypes.number,
  isResizable: PropTypes.bool,
  name: PropTypes.string,
  innerRef: PropTypes.oneOfType([PropTypes.func,
  /* eslint-disable-next-line react/forbid-prop-types */
  PropTypes.shape({
    current: PropTypes.object
  })]),
  label: function label(props) {
    var label = props.label;

    if (label) {
      if (label.type !== Label) return new Error('TextArea: label prop only accepts Aether Label component.');
      var labelType = label.props && label.props.type;
      if (labelType !== 'primary') return new Error('TextArea: label prop only accepts Label type primary.');
    }

    return null;
  },
  id: PropTypes.string
};