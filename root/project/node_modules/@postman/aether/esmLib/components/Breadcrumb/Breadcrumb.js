function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import React, { useEffect, useState } from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import Heading from '../Heading/Heading';
import Button from '../Button/Button';
import Popover from '../Popover/Popover';
import Text from '../Text/Text';
import { getComponentWidth } from '../../utils/common/index';
import { BreadcrumbDropdown, BreadcrumbDropdownItem } from './BreadcrumbDropdown';
var BREADCRUMB_TYPE_CONSTANTS = ['default', 'heading'];
/**
 * Function to get the typography styles based on the breadcrumb type
 * @param {*} type - the value of the type prop accepted by user
 * @param {*} theme - theme prop to access design tokens
 */

function getBreadcrumbTypographyStyles(type, theme) {
  if (type === 'default') {
    return "\n      font-size: ".concat(theme['text-size-m'], ";\n      line-height: ").concat(theme['line-height-s'], ";\n      font-weight: ").concat(theme['text-weight-regular'], ";\n    ");
  }

  return "\n    font-size: ".concat(theme['text-size-l'], ";\n    line-height: 1.44;\n    font-weight: ").concat(theme['text-weight-bold'], ";\n  ");
}
/**
 * Function to get the css styles for interaction states for a breadcrumb
 */


function getBreadcrumbItemInteractionStyles(theme) {
  return "\n          & li > a {\n            color: ".concat(theme['content-color-tertiary'], ";\n            border-bottom: ").concat(theme['border-width-default'], " ").concat(theme['border-style-solid'], " transparent;\n\n            &:focus-visible {\n              box-shadow: 0 0 0 2px ").concat(theme['breadcrumb-shadow-focus'], ";\n              outline: none;\n            }\n\n            &:hover {\n                border-bottom: ").concat(theme['border-width-default'], " ").concat(theme['border-style-solid'], ";\n                &:last-child {\n                  border-bottom: ").concat(theme['border-width-default'], " ").concat(theme['border-style-solid'], " transparent;\n                }\n            }\n          }\n        \n          &:hover {\n            li > a:not(:last-child) {\n                cursor: pointer;\n                transition: color .2s ease-in-out;\n                color: ").concat(theme['content-color-link'], ";\n            }\n\n            li:last-child {\n              color: ").concat(theme['content-color-secondary'], ";\n            }\n          }\n        ");
}

var StyledBreadcrumbContainer = styled.ul.withConfig({
  displayName: "Breadcrumb__StyledBreadcrumbContainer",
  componentId: "sc-dh6gt2-0"
})(["list-style-type:none;display:flex;align-items:center;padding:", ";margin:", ";", ";"], function (props) {
  return props.theme['spacing-zero'];
}, function (props) {
  return props.theme['spacing-zero'];
}, function (props) {
  return getBreadcrumbItemInteractionStyles(props.theme);
});
var StyledBreadcrumbItemContent = styled(Text).withConfig({
  displayName: "Breadcrumb__StyledBreadcrumbItemContent",
  componentId: "sc-dh6gt2-1"
})(["text-decoration:none;", ";", ";"], function (props) {
  return props.isTruncated && "max-width: 4ch;";
}, function (props) {
  return getBreadcrumbTypographyStyles(props.breadcrumbType, props.theme);
});
var StyledBreadcrumbItemContainer = styled.li.withConfig({
  displayName: "Breadcrumb__StyledBreadcrumbItemContainer",
  componentId: "sc-dh6gt2-2"
})(["width:max-content;display:inline-flex;white-space:nowrap;", " a{display:inline-block;}", ";", ";", ";", ";"], function (props) {
  return props.type === 'default' ? 'max-height: 16px;' : 'max-height: 20px;';
}, function (props) {
  return getBreadcrumbTypographyStyles(props.type, props.theme);
}, function (props) {
  return props.isLastChild ? "\n        color: ".concat(props.theme['content-color-tertiary'], ";\n    ") : null;
}, function (props) {
  return props.isLastItemTruncated && // added min-width to enable overflow of first item as overflowing requires some width specified on an element
  "\n    &:last-child {\n      min-width: 0;\n    } \n  ";
}, function (props) {
  return props.type === 'heading' ? "color: ".concat(props.theme['content-color-primary'], ";") : null;
});
var StyledBreadcrumbItemSeparator = styled.span.withConfig({
  displayName: "Breadcrumb__StyledBreadcrumbItemSeparator",
  componentId: "sc-dh6gt2-3"
})(["display:inline-block;margin:", " ", ";", ";color:", ";"], function (props) {
  return props.theme['spacing-zero'];
}, function (props) {
  return props.theme['spacing-xs'];
}, function (props) {
  return getBreadcrumbTypographyStyles(props.type, props.theme);
}, function (props) {
  return props.theme['content-color-tertiary'];
});
var StyledLastItemHeading = styled(Heading).withConfig({
  displayName: "Breadcrumb__StyledLastItemHeading",
  componentId: "sc-dh6gt2-4"
})(["display:inline-block;"]);
var StyledLastItemDefault = styled(Text).withConfig({
  displayName: "Breadcrumb__StyledLastItemDefault",
  componentId: "sc-dh6gt2-5"
})(["display:inline-block;", ";"], function (props) {
  return getBreadcrumbTypographyStyles('default', props.theme);
});

function BreadcrumbItemSeparator(props) {
  // eslint-disable-next-line react/prop-types
  var type = props.type;
  return /*#__PURE__*/React.createElement(StyledBreadcrumbItemSeparator, {
    type: type
  }, "\xA0/\xA0");
}

function BreadcrumbItem(props) {
  var children = props.children,
      type = props.type,
      onItemClick = props.onItemClick,
      itemData = props.itemData,
      __isLastChild = props.__isLastChild,
      __isFirstItemTruncated = props.__isFirstItemTruncated,
      __isLastItemTruncated = props.__isLastItemTruncated;

  var renderItems = function renderItems() {
    if (typeof children === 'string') {
      if (__isLastChild) {
        if (type === 'heading') {
          return /*#__PURE__*/React.createElement(StyledLastItemHeading, {
            type: "h2",
            styleAs: "h4",
            text: children,
            isTruncated: __isLastItemTruncated
          });
        }

        return /*#__PURE__*/React.createElement(StyledLastItemDefault, {
          isTruncated: __isLastItemTruncated
        }, children);
      }

      return /*#__PURE__*/React.createElement(StyledBreadcrumbItemContent, {
        __renderAs: "a",
        isTruncated: __isFirstItemTruncated,
        breadcrumbType: type,
        tabIndex: "0"
      }, children);
    }

    return children;
  };

  var handleOnKeyDown = function handleOnKeyDown(event) {
    // check if Enter key pressed
    if (event.keyCode === 13) {
      // stopping Fn calls for last breadcrumb item
      if (!__isLastChild) {
        if (onItemClick) onItemClick(itemData, event);
      }
    }
  };

  var handleClick = function handleClick(event) {
    // stopping Fn calls for last breadcrumb item
    if (!__isLastChild) {
      if (onItemClick) onItemClick(itemData, event);
    }
  };

  return /*#__PURE__*/React.createElement(StyledBreadcrumbItemContainer, {
    onClick: handleClick,
    type: type,
    isLastChild: __isLastChild,
    isLastItemTruncated: __isLastItemTruncated,
    onKeyDown: handleOnKeyDown
  }, renderItems(), !__isLastChild && /*#__PURE__*/React.createElement(BreadcrumbItemSeparator, {
    type: type
  }));
}

BreadcrumbItem.defaultProps = {
  __isLastChild: false,
  type: 'default',
  onItemClick: null,
  itemData: {},
  __isFirstItemTruncated: false,
  __isLastItemTruncated: false
};
BreadcrumbItem.propTypes = {
  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]).isRequired,
  __isLastChild: PropTypes.bool,
  type: PropTypes.oneOf(BREADCRUMB_TYPE_CONSTANTS),
  onItemClick: PropTypes.func,
  __isFirstItemTruncated: PropTypes.bool,
  __isLastItemTruncated: PropTypes.bool,
  // eslint-disable-next-line react/forbid-prop-types
  itemData: PropTypes.object
}; // functional component which renders the more item button (.../) for a truncated breadcrumb.

function MoreItemsButton(props) {
  var __isLastChild = props.__isLastChild,
      type = props.type,
      onItemClick = props.onItemClick,
      dropdownChildren = props.dropdownChildren;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isDropdownOpen = _useState2[0],
      setDropdownOpen = _useState2[1];

  var showDropdown = function showDropdown() {
    setDropdownOpen(true);
  };

  var hideDropdown = function hideDropdown() {
    setDropdownOpen(false);
  };

  var handleClickOutside = function handleClickOutside() {
    hideDropdown();
  };

  return /*#__PURE__*/React.createElement(BreadcrumbItem, {
    isLastChild: __isLastChild,
    type: type
  }, /*#__PURE__*/React.createElement(Popover, {
    isOpen: isDropdownOpen,
    onClickOutside: handleClickOutside,
    padding: "spacing-zero",
    trigger: /*#__PURE__*/React.createElement(Button, {
      type: "muted-plain",
      text: "...",
      onClick: isDropdownOpen ? hideDropdown : showDropdown
    })
  }, /*#__PURE__*/React.createElement(BreadcrumbDropdown, {
    isDropdownOpen: isDropdownOpen,
    onItemClick: onItemClick,
    hideDropdown: hideDropdown
  }, dropdownChildren && dropdownChildren.map(function (child, index) {
    var itemKey = "BreadcrumbDropdown".concat(index);
    return /*#__PURE__*/React.createElement(BreadcrumbDropdownItem, {
      itemData: child.props.itemData || {},
      itemId: index,
      key: itemKey,
      onItemClick: onItemClick
    }, child.props.children);
  }))));
}

MoreItemsButton.defaultProps = {
  __isLastChild: false,
  type: 'default',
  onItemClick: null,
  dropdownChildren: []
};
MoreItemsButton.propTypes = {
  __isLastChild: PropTypes.bool,
  type: PropTypes.oneOf(BREADCRUMB_TYPE_CONSTANTS),
  onItemClick: PropTypes.func,
  dropdownChildren: PropTypes.arrayOf(PropTypes.shape({
    type: PropTypes.oneOf([BreadcrumbItem])
  }))
};

function Breadcrumb(props) {
  var children = props.children,
      type = props.type,
      onItemClick = props.onItemClick,
      className = props.className;
  var breadcrumbRef = /*#__PURE__*/React.createRef();

  var handleOnItemClick = function handleOnItemClick(item) {
    if (onItemClick) {
      onItemClick(item);
    }
  };

  var _useState3 = useState(React.Children.toArray(children)),
      _useState4 = _slicedToArray(_useState3, 2),
      visibleChildren = _useState4[0],
      setVisibleChildren = _useState4[1];

  var _useState5 = useState([]),
      _useState6 = _slicedToArray(_useState5, 2),
      dropdownChildren = _useState6[0],
      setDropdownChildren = _useState6[1];

  var _useState7 = useState(true),
      _useState8 = _slicedToArray(_useState7, 2),
      isPortalVisible = _useState8[0],
      setPortalVisible = _useState8[1];

  var updatedChildren = React.Children.map(children, function (child, index) {
    return /*#__PURE__*/React.cloneElement(child, {
      __isLastChild: React.Children.toArray(children).length === index + 1,
      type: type,
      onItemClick: handleOnItemClick
    });
  });
  var breadcrumbPortalRef = /*#__PURE__*/React.createRef();
  var moreButtonPortalRef = /*#__PURE__*/React.createRef();
  var breadcrumbPortalJsx = getComponentWidth( /*#__PURE__*/React.createElement(StyledBreadcrumbContainer, {
    style: {
      width: 'max-content',
      display: 'inline-block'
    },
    type: type,
    ref: breadcrumbPortalRef
  }, updatedChildren)).renderedElement;
  var moreButtonPortalJsx = getComponentWidth( /*#__PURE__*/React.createElement(StyledBreadcrumbContainer, {
    type: type,
    ref: moreButtonPortalRef
  }, /*#__PURE__*/React.createElement(MoreItemsButton, {
    __isLastChild: false,
    type: type,
    onItemClick: onItemClick
  }))).renderedElement;
  var breadcrumbPortalChildren;
  var breadcrumbPortalChildrenWidth;
  var truncatedFirstItemWidth;
  var breadcrumbPortalChildrenWidthArray = [];
  var moreButtonPortalWidth = 0;
  useEffect(function () {
    if (moreButtonPortalRef && moreButtonPortalRef.current) {
      moreButtonPortalWidth = moreButtonPortalRef.current.children[0].offsetWidth;
    }
  }, [children]);
  useEffect(function () {
    // only run the effect if dummy breadcrumbs are present in this div
    if (breadcrumbPortalRef && breadcrumbPortalRef.current) {
      breadcrumbPortalChildren = breadcrumbPortalRef.current.children;
      breadcrumbPortalChildrenWidth = breadcrumbPortalRef.current.offsetWidth;

      for (var i = 0; i < breadcrumbPortalChildren.length;) {
        breadcrumbPortalChildrenWidthArray.push(breadcrumbPortalChildren[i].offsetWidth);
        i += 1;
      }

      var firstItemTruncationStyles = {
        display: 'inline-block',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap',
        maxWidth: '4ch'
      };
      Object.assign(breadcrumbPortalChildren[0].children[0].style, firstItemTruncationStyles);
      truncatedFirstItemWidth = breadcrumbPortalChildren[0].offsetWidth; // remove the truncation styles for new children, after width is calculated

      firstItemTruncationStyles = {
        display: 'initial',
        overflow: 'initial',
        textOverflow: 'initial',
        whiteSpace: 'initial',
        maxWidth: 'initial'
      };
      Object.assign(breadcrumbPortalChildren[0].children[0].style, firstItemTruncationStyles);
    }
  }, [children, type]);
  var clonedChildren = React.Children.map(visibleChildren, function (child, index) {
    return /*#__PURE__*/React.cloneElement(child, {
      __isLastChild: React.Children.toArray(visibleChildren).length === index + 1,
      type: type,
      onItemClick: handleOnItemClick,
      dropdownChildren: dropdownChildren
    });
  }); // function to handle breadcrumb truncation if the width is small to accomodate all items
  // Runs everytime the width of the breadcrumb changes.
  // Everytime this function computes the visibleChildren of the breadcrumb and the dropdownChildren in case of truncation

  var handleBreadcrumbTruncation = function handleBreadcrumbTruncation(entries) {
    var newDropdownChildren = [];
    var availableBreadcrumbWidth = breadcrumbPortalChildrenWidthArray[0] + moreButtonPortalWidth + breadcrumbPortalChildrenWidthArray[updatedChildren.length - 1];
    var newVisibleChildren = [updatedChildren[0], /*#__PURE__*/React.createElement(MoreItemsButton, null), updatedChildren[updatedChildren.length - 1]]; // If the width is increasing, show the whole breadcrumb items again

    if (breadcrumbPortalChildrenWidth <= entries[0].contentRect.width) {
      // render the original children back
      setVisibleChildren(updatedChildren);
      return;
    } // determine the breadcrumb children that can be shown in the available width
    // this if statement only runs for breadcrumbs having 3 or more items


    if (availableBreadcrumbWidth < entries[0].contentRect.width && updatedChildren.length >= 3) {
      var i = 0; // eslint-disable-next-line no-plusplus

      for (i = updatedChildren.length - 2; i >= 1; i--) {
        // keep adding elements to visibleChildren array till overflow occurs
        if (availableBreadcrumbWidth + breadcrumbPortalChildrenWidthArray[i] <= entries[0].contentRect.width) {
          availableBreadcrumbWidth += breadcrumbPortalChildrenWidthArray[i];
          newVisibleChildren.splice(2, 0, updatedChildren[i]);
        } else {
          break;
        }
      } // push the dropdown children in newDropdownChildren array
      // eslint-disable-next-line no-plusplus


      for (; i >= 1; i--) {
        newDropdownChildren.splice(0, 0, /*#__PURE__*/React.cloneElement(updatedChildren[i], {
          onClick: onItemClick
        }));
      }

      setVisibleChildren(newVisibleChildren);
      setDropdownChildren(newDropdownChildren);
    } // Checks if further truncation is required
    // this if statement only runs for breadcrumbs having 2 or more items


    var moreOptionsWidth;

    if (updatedChildren.length > 1 && typeof updatedChildren[0].props.children === 'string' && updatedChildren[0].props.children.length >= 5) {
      // find the newDropdown children based on how many items the breadcrumb has as children
      if (updatedChildren.length <= 2) {
        newDropdownChildren = [];
      } else {
        newDropdownChildren = [];

        for (var _i2 = 1; _i2 <= updatedChildren.length - 2;) {
          newDropdownChildren.push(updatedChildren[_i2]);
          _i2 += 1;
        }
      }

      moreOptionsWidth = newDropdownChildren.length > 0 ? moreButtonPortalWidth : 0; // check if overflow still happens, if yes then truncate the first item

      if (breadcrumbPortalChildrenWidthArray[0] + moreOptionsWidth + breadcrumbPortalChildrenWidthArray[updatedChildren.length - 1] > entries[0].contentRect.width) {
        if (updatedChildren.length === 2) {
          newVisibleChildren = [/*#__PURE__*/React.cloneElement(updatedChildren[0], {
            __isFirstItemTruncated: true,
            __isLastItemTruncated: false
          }), updatedChildren[updatedChildren.length - 1]];
        } else {
          // truncate the first element and update the children
          newVisibleChildren[0] = /*#__PURE__*/React.cloneElement(newVisibleChildren[0], {
            __isFirstItemTruncated: true,
            __isLastItemTruncated: false
          });
        }

        setDropdownChildren(_toConsumableArray(newDropdownChildren));
        setVisibleChildren(newVisibleChildren);
      } // if still overflow occurs, add first child to moreItems dropdown


      moreOptionsWidth = newDropdownChildren.length > 0 ? moreButtonPortalWidth : 0;

      if (truncatedFirstItemWidth + moreOptionsWidth + breadcrumbPortalChildrenWidthArray[updatedChildren.length - 1] > entries[0].contentRect.width) {
        if (updatedChildren.length === 2) {
          newVisibleChildren = [/*#__PURE__*/React.createElement(MoreItemsButton, null), /*#__PURE__*/React.cloneElement(updatedChildren[updatedChildren.length - 1], {
            __isLastItemTruncated: true
          })];
          newDropdownChildren = [updatedChildren[0]];
        } else {
          newDropdownChildren.splice(0, 0, updatedChildren[0]);
          newVisibleChildren.splice(0, 1);
          newVisibleChildren[newVisibleChildren.length - 1] = /*#__PURE__*/React.cloneElement(newVisibleChildren[newVisibleChildren.length - 1], {
            __isLastItemTruncated: true
          });
        } // update visible children and dropdown children


        setVisibleChildren(newVisibleChildren);
        setDropdownChildren(_toConsumableArray(newDropdownChildren));
      }

      return;
    } // edge case: If breadcrumb has only one item
    // check if overflow occurs, if yes then truncate the last item


    if (breadcrumbPortalChildrenWidthArray[0] > entries[0].contentRect.width) {
      newVisibleChildren = [/*#__PURE__*/React.cloneElement(updatedChildren[0], {
        __isLastItemTruncated: true
      })]; // set the state to show new visible children

      setVisibleChildren(_toConsumableArray(newVisibleChildren));
    }
  }; // to define the Resizebserver api


  var observer = new ResizeObserver(handleBreadcrumbTruncation);
  useEffect(function () {
    observer.observe(breadcrumbRef.current); // for (const child of breadcrumbRef.current.children) {
    //   observer.observe(child);
    // }

    return function () {
      observer.disconnect();
    };
  }, [children]);
  useEffect(function () {
    return function () {
      setPortalVisible(false);
    };
  }, []);
  return /*#__PURE__*/React.createElement("nav", {
    className: className
  }, /*#__PURE__*/React.createElement(StyledBreadcrumbContainer, {
    type: type,
    ref: breadcrumbRef
  }, clonedChildren), isPortalVisible && breadcrumbPortalJsx, isPortalVisible && moreButtonPortalJsx);
}

Breadcrumb.defaultProps = {
  type: 'default',
  onItemClick: null,
  children: null,
  className: ''
};
Breadcrumb.propTypes = {
  children: function children(_ref) {
    var _children = _ref.children;

    if (!_children) {
      return new Error('Breadcrumb: children prop cannot be left empty.');
    } // check if children is a single object and not an array


    if (Array.isArray(_children)) {
      var isErrorMsg = false;

      _children.forEach(function (child) {
        if (child.type !== BreadcrumbItem) {
          isErrorMsg = true;
        }
      });

      if (isErrorMsg) {
        return new Error('Breadcrumb: should only have BreadcrumbItem as child');
      }
    } else if (_children.type !== BreadcrumbItem) {
      return new Error('Breadcrumb: should only have BreadcrumbItem as child');
    }

    return null;
  },
  type: PropTypes.oneOf(BREADCRUMB_TYPE_CONSTANTS),
  onItemClick: PropTypes.func,
  className: PropTypes.string
};
export { Breadcrumb, BreadcrumbItem };