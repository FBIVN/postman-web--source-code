function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

import React from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import { spanToClass, hiddenForToClass } from '../../utils/common/index';
import { SPAN_TO_TEXT_MAP, TABLET, COMPUTER, MOBILE, ALL_DEVICES, TYPE_COLUMN, TYPE_ROW } from '../../utils/constants/index';
import { globals, aliases } from '../../design-tokens/tokens';
import ResponsiveContainerTokens from './ResponsiveContainerToken'; // max width accepts all valid css max-width value along with two tokens, parsing the values here

function resolveMaxWidth(val) {
  if (val === 'container-width-large' || val === 'container-width-medium') return ResponsiveContainerTokens[val];
  return val;
}

function getBorderStyles(_ref, theme) {
  var border = _ref.border,
      borderTop = _ref.borderTop,
      borderBottom = _ref.borderBottom,
      borderLeft = _ref.borderLeft,
      borderRight = _ref.borderRight,
      borderColor = _ref.borderColor,
      borderStyle = _ref.borderStyle;
  return "\n    ".concat(border ? "border: ".concat(theme[border], " ").concat(theme['border-style-solid'], " ").concat(theme['border-color-default'], ";") : '', "\n    ").concat(borderTop ? "border-top: ".concat(theme[borderTop], " ").concat(theme['border-style-solid'], " ").concat(theme['border-color-default'], ";") : '', "\n    ").concat(borderBottom ? "border-bottom: ".concat(theme[borderBottom], " ").concat(theme['border-style-solid'], " ").concat(theme['border-color-default'], ";") : '', "\n    ").concat(borderLeft ? "border-left: ".concat(theme[borderLeft], " ").concat(theme['border-style-solid'], " ").concat(theme['border-color-default'], ";") : '', "\n    ").concat(borderRight ? "border-right: ".concat(theme[borderRight], " ").concat(theme['border-style-solid'], " ").concat(theme['border-color-default'], ";") : '', "\n    ").concat(borderColor ? "border-color: ".concat(theme[borderColor], ";") : '', "\n    ").concat(borderStyle ? "border-style: ".concat(theme[borderStyle], ";") : '', "\n  ");
}
/**
 * @description This function verifies whether provided values are defined spacing design tokens
 * and warns otherwise.
 * @param {string} spacingTokens padding values in a form of space separated string
 */


function validateSpacingTokens(spacingTokens) {
  var isMarginValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  for (var index = 0; index < spacingTokens.length; index += 1) {
    var token = spacingTokens[index];

    if (!globals.spacing[token]) {
      if (!(isMarginValidation && token === 'auto')) {
        // eslint-disable-next-line no-console
        console.warn("ResponsiveContainer: ".concat(token, " Unsupported value provided, Please provide values from the given list ").concat(Object.keys(globals.spacing)));
      }
    }
  }
} // generates the padding value


function getPadding(paddingVal) {
  var paddingValues = [];
  var padding = typeof paddingVal === 'string' ? paddingVal.trim() : paddingVal;

  if (_typeof(padding) === 'object') {
    var paddingTop = padding.paddingTop,
        paddingBottom = padding.paddingBottom,
        paddingLeft = padding.paddingLeft,
        paddingRight = padding.paddingRight;
    return "\n      ".concat(paddingTop ? "padding-top: ".concat(globals.spacing[paddingTop], ";") : '', "\n      ").concat(paddingBottom ? "padding-bottom: ".concat(globals.spacing[paddingBottom], ";") : '', "\n      ").concat(paddingLeft ? "padding-left: ".concat(globals.spacing[paddingLeft], ";") : '', "\n      ").concat(paddingRight ? "padding-right: ".concat(globals.spacing[paddingRight], ";") : '', "\n    ");
  } // case when padding is provided as string


  paddingValues = padding.split(' '); // verifies whether provided values are defined spacing design tokens and warns otherwise

  validateSpacingTokens(paddingValues);

  switch (paddingValues.length) {
    case 1:
      return "padding: ".concat(globals.spacing[paddingValues[0]], ";");

    case 2:
      return "padding: ".concat(globals.spacing[paddingValues[0]], " ").concat(globals.spacing[paddingValues[1]], ";");

    case 3:
      return "padding: ".concat(globals.spacing[paddingValues[0]], " ").concat(globals.spacing[paddingValues[1]], " ").concat(globals.spacing[paddingValues[2]], ";");

    case 4:
      return "\n        padding: ".concat(globals.spacing[paddingValues[0]], "\n          ").concat(globals.spacing[paddingValues[1]], "\n          ").concat(globals.spacing[paddingValues[2]], "\n          ").concat(globals.spacing[paddingValues[3]], ";");

    default:
      return '';
  }
} // generates the margin value


function getMargin(marginVal) {
  var marginValues = [];
  var margin = typeof marginVal === 'string' ? marginVal.trim() : marginVal;

  if (_typeof(margin) === 'object') {
    var marginTop = margin.marginTop,
        marginBottom = margin.marginBottom,
        marginLeft = margin.marginLeft,
        marginRight = margin.marginRight;
    return "\n      ".concat(marginTop ? "margin-top: ".concat(globals.spacing[marginTop], ";") : '', "\n      ").concat(marginBottom ? "margin-bottom: ".concat(globals.spacing[marginBottom], ";") : '', "\n      ").concat(marginLeft ? "margin-left: ".concat(globals.spacing[marginLeft], ";") : '', "\n      ").concat(marginRight ? "margin-right: ".concat(globals.spacing[marginRight], ";") : '', "\n    ");
  } // case when margin auto provided


  if (margin === 'auto') {
    return "margin: auto;";
  } // case when margin is provided as string but not auto


  marginValues = margin.split(' '); // verifies whether provided values are defined spacing design tokens and warns otherwise

  validateSpacingTokens(marginValues, true);

  if (marginValues[0]) {
    marginValues[0] = marginValues[0] === 'auto' ? 'auto' : globals.spacing[marginValues[0]];
  }

  if (marginValues[1]) {
    marginValues[1] = marginValues[1] === 'auto' ? 'auto' : globals.spacing[marginValues[1]];
  }

  if (marginValues[2]) {
    marginValues[2] = marginValues[2] === 'auto' ? 'auto' : globals.spacing[marginValues[2]];
  }

  if (marginValues[3]) {
    marginValues[3] = marginValues[3] === 'auto' ? 'auto' : globals.spacing[marginValues[3]];
  }

  switch (marginValues.length) {
    case 1:
      return "margin: ".concat(marginValues[0], ";");

    case 2:
      return "margin: ".concat(marginValues[0], " ").concat(marginValues[1], ";");

    case 3:
      return "margin: ".concat(marginValues[0], " ").concat(marginValues[1], " ").concat(marginValues[2], ";");

    case 4:
      return "\n        margin: ".concat(marginValues[0], "\n          ").concat(marginValues[1], "\n          ").concat(marginValues[2], "\n          ").concat(marginValues[3], ";");

    default:
      return '';
  }
}

function generateClassNames(computer, tablet, mobile, span, hiddenFor) {
  var classes = [];
  if (span && typeof SPAN_TO_TEXT_MAP[span] !== 'undefined') classes.push(spanToClass(ALL_DEVICES, span));
  if (computer && typeof SPAN_TO_TEXT_MAP[computer] !== 'undefined') classes.push(spanToClass(COMPUTER, computer));
  if (tablet && typeof SPAN_TO_TEXT_MAP[tablet] !== 'undefined') classes.push(spanToClass(TABLET, tablet));
  if (mobile && typeof SPAN_TO_TEXT_MAP[mobile] !== 'undefined') classes.push(spanToClass(MOBILE, mobile));
  if (hiddenFor.length > 0) classes.push(hiddenForToClass(hiddenFor));
  return classes.join(' ');
} // column styled elements


var StyledResponsiveContainerColumn = styled.div.withConfig({
  displayName: "ResponsiveContainer__StyledResponsiveContainerColumn",
  componentId: "sc-zfeeh0-0"
})(["display:grid;overflow:", ";", " ", " box-sizing:border-box;max-width:", ";max-height:", ";min-height:", ";height:max-content;row-gap:", ";", ""], function (props) {
  return props.overflow;
}, function (props) {
  return getMargin(props.margin);
}, function (props) {
  return getPadding(props.padding);
}, function (props) {
  return resolveMaxWidth(props.maxWidth);
}, function (props) {
  return props.maxHeight;
}, function (props) {
  return props.minHeight;
}, function (props) {
  return props.rowGap ? "".concat(props.theme[props.rowGap]) : '';
}, function (props) {
  return props.border && getBorderStyles(props.border, props.theme);
}); // row styled elements

var StyledResponsiveContainerRow = styled.div.withConfig({
  displayName: "ResponsiveContainer__StyledResponsiveContainerRow",
  componentId: "sc-zfeeh0-1"
})(["display:grid;", " overflow:", ";", " ", " box-sizing:border-box;", " max-width:", ";max-height:", ";min-height:", ";column-gap:", ";row-gap:", ";"], function (props) {
  return props.type === TYPE_ROW ? 'grid-template-columns: repeat(12, 1fr);' : '';
}, function (props) {
  return props.overflow;
}, function (props) {
  return getMargin(props.margin);
}, function (props) {
  return getPadding(props.padding);
}, function (props) {
  return props.border && getBorderStyles(props.border, props.theme);
}, function (props) {
  return resolveMaxWidth(props.maxWidth);
}, function (props) {
  return props.maxHeight;
}, function (props) {
  return props.minHeight;
}, function (props) {
  return props.columnGap ? "".concat(props.theme[props.columnGap]) : '';
}, function (props) {
  return props.rowGap ? "".concat(props.theme[props.rowGap]) : '';
});
export default function ResponsiveContainer(props) {
  var children = props.children,
      computer = props.computer,
      tablet = props.tablet,
      mobile = props.mobile,
      span = props.span,
      maxWidth = props.maxWidth,
      maxHeight = props.maxHeight,
      minHeight = props.minHeight,
      border = props.border,
      type = props.type,
      margin = props.margin,
      padding = props.padding,
      hiddenFor = props.hiddenFor,
      className = props.className,
      gap = props.gap,
      overflow = props.overflow;
  var classes = generateClassNames(computer, tablet, mobile, span, hiddenFor);

  if (className) {
    classes = "".concat(classes, " ").concat(className);
  }

  if (type === TYPE_COLUMN) return /*#__PURE__*/React.createElement(StyledResponsiveContainerColumn, {
    border: border,
    maxWidth: maxWidth,
    padding: padding,
    margin: margin,
    className: classes,
    maxHeight: maxHeight,
    minHeight: minHeight,
    rowGap: gap,
    overflow: overflow
  }, children);
  return /*#__PURE__*/React.createElement(StyledResponsiveContainerRow, {
    border: border,
    maxWidth: maxWidth,
    maxHeight: maxHeight,
    minHeight: minHeight,
    margin: margin,
    padding: padding,
    className: classes,
    columnGap: gap,
    rowGap: gap,
    type: type,
    overflow: overflow
  }, children);
}
ResponsiveContainer.defaultProps = {
  computer: null,
  tablet: null,
  mobile: null,
  type: '',
  span: 12,
  maxWidth: null,
  maxHeight: null,
  minHeight: null,
  border: null,
  hiddenFor: [],
  margin: 'spacing-zero',
  padding: 'spacing-zero',
  className: '',
  gap: 'spacing-xl',
  overflow: 'auto'
};
ResponsiveContainer.propTypes = {
  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]).isRequired,
  computer: PropTypes.number,
  tablet: PropTypes.number,
  mobile: PropTypes.number,
  span: PropTypes.number,
  type: PropTypes.string,
  overflow: PropTypes.string,
  gap: PropTypes.oneOf(Object.keys(globals.spacing)),
  maxWidth: PropTypes.string,
  maxHeight: PropTypes.string,
  minHeight: PropTypes.string,
  margin: PropTypes.oneOfType([PropTypes.oneOf(Object.keys(globals.spacing)), PropTypes.shape({
    marginTop: PropTypes.string,
    marginBottom: PropTypes.string,
    marginLeft: PropTypes.string,
    marginRight: PropTypes.string
  }), PropTypes.string, 'auto']),
  padding: PropTypes.oneOfType([PropTypes.oneOf(Object.keys(globals.spacing)), PropTypes.shape({
    paddingTop: PropTypes.string,
    paddingBottom: PropTypes.string,
    paddingLeft: PropTypes.string,
    paddingRight: PropTypes.string
  }), PropTypes.string]),
  border: PropTypes.shape({
    border: PropTypes.oneOf(['border-width-default', 'border-width-l', 'border-width-xl']),
    borderTop: PropTypes.oneOf(['border-width-default', 'border-width-l', 'border-width-xl']),
    borderBottom: PropTypes.oneOf(['border-width-default', 'border-width-l', 'border-width-xl']),
    borderLeft: PropTypes.oneOf(['border-width-default', 'border-width-l', 'border-width-xl']),
    borderRight: PropTypes.oneOf(['border-width-default', 'border-width-l', 'border-width-xl']),
    borderStyle: PropTypes.oneOf(['border-style-solid', 'border-style-dashed']),
    borderColor: PropTypes.oneOf(Object.keys(aliases.light.border))
  }),
  hiddenFor: PropTypes.arrayOf(PropTypes.oneOf([MOBILE, TABLET, COMPUTER])),
  className: PropTypes.string
};