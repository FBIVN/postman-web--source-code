'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _isString = require('lodash/isString');

var _isString2 = _interopRequireDefault(_isString);

var _isNumber = require('lodash/isNumber');

var _isNumber2 = _interopRequireDefault(_isNumber);

var _isBoolean = require('lodash/isBoolean');

var _isBoolean2 = _interopRequireDefault(_isBoolean);

var _isArray = require('lodash/isArray');

var _isArray2 = _interopRequireDefault(_isArray);

var _isObject = require('lodash/isObject');

var _isObject2 = _interopRequireDefault(_isObject);

var _forEach = require('lodash/forEach');

var _forEach2 = _interopRequireDefault(_forEach);

var _forOwn = require('lodash/forOwn');

var _forOwn2 = _interopRequireDefault(_forOwn);

var _concat = require('lodash/concat');

var _concat2 = _interopRequireDefault(_concat);

var _reject = require('lodash/reject');

var _reject2 = _interopRequireDefault(_reject);

var _size = require('lodash/size');

var _size2 = _interopRequireDefault(_size);

var _assign = require('lodash/assign');

var _assign2 = _interopRequireDefault(_assign);

var _get = require('lodash/get');

var _get2 = _interopRequireDefault(_get);

var _immutable = require('immutable');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var utils = function () {
  function utils() {
    _classCallCheck(this, utils);

    this.counter = 0;
  }

  _createClass(utils, [{
    key: 'getId',
    value: function getId() {
      return this.counter++;
    }
  }, {
    key: '_getType',
    value: function _getType(item) {
      if ((0, _isString2.default)(item)) return 'string';
      if ((0, _isNumber2.default)(item)) return 'number';
      if ((0, _isBoolean2.default)(item)) return 'boolean';
      if ((0, _isArray2.default)(item)) return 'array';
      if ((0, _isObject2.default)(item)) return 'object';
    }

    /**
     * Recursively flattens a node
     *
     * @param  {?Number} nodeId     - The current node's ID. If not provided, an ID will be generated
     * @param  {String} columnName  - This is the name of the column, as per the config
     * @param  {*}      columnValue - Value of the node we are currently flattening
     * @param  {Number} depth       - Depth of the node we are currently flattening
     * @param  {?String} columnKey   - Optional name of the node we are currently flattening
     * 
     * @return {undefined}
     */

  }, {
    key: 'flattenNode',
    value: function flattenNode(nodeId, columnName, columnValue) {
      var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var columnKey = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';

      var _this = this;

      var autogen = arguments[5];
      var parent = arguments[6];

      var columnType = this._getType(columnValue),
          id = nodeId,
          allChildren = [],
          children = [];

      if (id === null || typeof id === 'undefined') {
        id = this.getId();
        this.flattened.order = (0, _concat2.default)(this.flattened.order, id);
      }

      if (this.maxDepth < depth) {
        this.maxDepth = depth;
      }

      switch (columnType) {
        case 'string':
        case 'number':
        case 'boolean':
          this.flattened.rows[id] = Object.assign({}, this.flattened.rows[id], {
            id: id,
            depth: depth,
            parent: parent,
            columns: Object.assign({}, (0, _get2.default)(this.flattened.rows[id], 'columns', []), _defineProperty({}, '' + columnName, {
              type: columnType,
              meta: {
                value: columnValue
              }
            }))

            // children.push(id);
          });allChildren.push(id);
          break;

        case 'array':
          children.push(id);
          allChildren.push(id);
          (0, _forEach2.default)(columnValue, function (colVal, colIndex) {
            if ((0, _isString2.default)(colVal) || (0, _isNumber2.default)(colVal) || (0, _isBoolean2.default)(colVal)) {
              // Value is a simple object
              var newId = _this.getId();
              _this.flattened.rows[newId] = Object.assign({}, _this.flattened.rows[newId], {
                id: newId,
                depth: depth + 1,
                parent: id,
                columns: Object.assign({}, (0, _get2.default)(_this.flattened.rows[newId], 'columns', []), _defineProperty({}, '' + columnName, {
                  type: 'object',
                  meta: {
                    key: columnKey + '[' + colIndex + ']',
                    value: colVal,
                    type: _this._getType(colVal)
                  }
                }))
              });

              _this.flattened.order = (0, _concat2.default)(_this.flattened.order, newId);
              children.push(newId);
              allChildren.push(newId);
            } else {
              var flatChildren = _this.flattenNode(null, columnName, colVal, depth + 1, columnKey + '[' + colIndex + ']', true, id);
              allChildren = (0, _concat2.default)(allChildren, flatChildren.allChildren);
              var directChildren = (0, _reject2.default)(flatChildren.children, function (child) {
                return _this.flattened.rows[child].depth !== depth + 1;
              });
              children = (0, _concat2.default)(children, directChildren);
            }
          });

          this.flattened.rows[id] = Object.assign({}, this.flattened.rows[id], {
            id: id,
            depth: depth,
            parent: parent,
            children: (0, _reject2.default)(children, function (child) {
              return '' + child === '' + id;
            }),
            allChildren: (0, _reject2.default)(allChildren, function (child) {
              return '' + child === '' + id;
            }),
            columns: Object.assign({}, (0, _get2.default)(this.flattened.rows[id], 'columns', []), _defineProperty({}, '' + columnName, {
              type: 'arraymeta',
              meta: {
                name: columnKey,
                childrenCount: (0, _size2.default)(columnValue),
                type: this._getType(columnValue)
              }
            }))
          });
          break;

        case 'object':
          children.push(id);
          allChildren.push(id);
          (0, _forOwn2.default)(columnValue, function (colVal, colKey) {
            if ((0, _isString2.default)(colVal) || (0, _isNumber2.default)(colVal) || (0, _isBoolean2.default)(colVal)) {
              // Value is a simple object
              var newId = _this.getId();
              _this.flattened.rows[newId] = Object.assign({}, _this.flattened.rows[newId], {
                id: newId,
                depth: depth + 1,
                parent: id,
                columns: Object.assign({}, (0, _get2.default)(_this.flattened.rows[newId], 'columns', []), _defineProperty({}, '' + columnName, {
                  type: 'object',
                  meta: {
                    key: '' + colKey,
                    value: colVal,
                    type: _this._getType(colVal)
                  }
                }))
              });

              _this.flattened.order = (0, _concat2.default)(_this.flattened.order, newId);
              children.push(newId);
              allChildren.push(newId);
            } else {
              var flatChildren = _this.flattenNode(null, columnName, colVal, depth + 1, colKey, false, id);
              allChildren = (0, _concat2.default)(allChildren, flatChildren.allChildren);
              var directChildren = (0, _reject2.default)(flatChildren.children, function (child) {
                return _this.flattened.rows[child].depth !== depth + 1;
              });
              children = (0, _concat2.default)(children, directChildren);
            }
          });

          this.flattened.rows[id] = Object.assign({}, this.flattened.rows[id], {
            id: id,
            depth: depth,
            parent: parent,
            children: (0, _reject2.default)(children, function (child) {
              return '' + child === '' + id;
            }),
            allChildren: (0, _reject2.default)(allChildren, function (child) {
              return '' + child === '' + id;
            }),
            columns: Object.assign({}, (0, _get2.default)(this.flattened.rows[id], 'columns', []), _defineProperty({}, '' + columnName, {
              type: 'objectmeta',
              meta: {
                name: columnKey,
                autogen: autogen,
                childrenCount: (0, _size2.default)(columnValue),
                type: this._getType(columnValue)
              }
            }))
          });
          break;

        default:
          break;
      }

      return {
        children: children,
        allChildren: allChildren
      };
    }
  }, {
    key: 'flattenNodes',
    value: function flattenNodes(config, input) {
      var _this2 = this;

      delete this.flattened;
      this.flattened = {
        rows: {},
        order: [],
        collapsedRows: {}
      };
      this.maxDepth = 0;

      (0, _forEach2.default)(input, function (datum) {
        var id = _this2.getId();
        _this2.flattened.order = (0, _concat2.default)(_this2.flattened.order, id);

        (0, _forEach2.default)(config.columns, function (column) {
          switch (column.type) {
            case 'string':
            case 'number':
            case 'boolean':
              _this2.flattened.rows[id] = Object.assign({}, _this2.flattened.rows[id], {
                id: id,
                depth: 0,
                columns: Object.assign({}, (0, _get2.default)(_this2.flattened.rows[id], 'columns', []), _defineProperty({}, '' + column.name, {
                  type: column.type,
                  meta: {
                    value: datum[column.name]
                  }
                }))
              });
              break;
            case 'object':
            case 'array':
              var value = datum[column.name];
              var colKey = value.key;
              var colVal = value.value;
              if ((0, _isString2.default)(colVal) || (0, _isNumber2.default)(colVal) || (0, _isBoolean2.default)(colVal)) {
                _this2.flattened.rows[id] = Object.assign({}, _this2.flattened.rows[id], {
                  id: id,
                  depth: 0,
                  columns: Object.assign({}, (0, _get2.default)(_this2.flattened.rows[id], 'columns', []), _defineProperty({}, '' + column.name, {
                    type: 'object',
                    meta: {
                      key: '' + colKey,
                      value: colVal,
                      type: 'string'
                    }
                  }))
                });
              } else {
                _this2.flattenNode(id, column.name, colVal, 0, colKey);
              }
              break;
            default:
              break;
          }
        });
      });

      return {
        state: (0, _immutable.fromJS)(this.flattened),
        maxDepth: this.maxDepth
      };
    }
  }, {
    key: 'unflattenChildren',
    value: function unflattenChildren(state, columnName, children) {
      var _this3 = this;

      var startingValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      var value = startingValue;

      (0, _forEach2.default)(children, function (childId) {
        var child = state.rows['' + childId];

        if (child.columns[columnName].type === 'object') {
          // console.log('object', this._getType(value))
          _this3._getType(value) === 'object' && (value = Object.assign({}, value, _defineProperty({}, child.columns[columnName].meta.key, child.columns[columnName].meta.value)));

          _this3._getType(value) === 'array' && (value = [].concat(_toConsumableArray(value), [_defineProperty({}, child.columns[columnName].meta.key, child.columns[columnName].meta.value)]));

          // console.log(JSON.stringify(value))
        } else if (child.columns[columnName].type === 'objectmeta') {
          // console.log('objectmeta', this._getType(value))
          _this3._getType(value) === 'object' && (value = _defineProperty({}, child.columns[columnName].meta.name, _this3.unflattenChildren(state, columnName, child.children, {})));

          // console.log(child.columns[columnName].meta.name, this._getType(value) === 'array' && !child.columns[columnName].meta.autogen)

          // children[0]
          _this3._getType(value) === 'array' && !child.columns[columnName].meta.autogen && (value = [_assign2.default.apply(undefined, [{}].concat(_toConsumableArray(value), [_defineProperty({}, child.columns[columnName].meta.name, _this3.unflattenChildren(state, columnName, child.children, {}))]))]);

          // other objects
          _this3._getType(value) === 'array' && child.columns[columnName].meta.autogen && (value = _this3.unflattenChildren(state, columnName, child.children, value));
        } else if (child.columns[columnName].type === 'arraymeta') {
          // console.log('arraymeta', this._getType(value))
          _this3._getType(value) === 'object' && (value = _defineProperty({}, child.columns[columnName].meta.name, _this3.unflattenChildren(state, columnName, child.children, [])));

          _this3._getType(value) === 'array' && (value = _this3.unflattenChildren(state, columnName, child.children, []));
        }

        // console.log('value', JSON.stringify(value))
      });

      return value;
    }
  }, {
    key: 'unflattenNodes',
    value: function unflattenNodes(is) {
      var _this4 = this;

      var state = is.toJS();
      var input = [],
          inputValueIndex = 0; // This is the index of the input we're generating

      var order = state.order;

      (0, _forEach2.default)(order, function (nodeId) {
        var node = state.rows[nodeId],
            depth = node.depth;

        (0, _forOwn2.default)(node.columns, function (column, columnName) {
          if (depth !== 0) {
            // console.log(node)
            // input = this.unflattenChildren({ input, inputValueIndex, columnName }, node.allChildren, state)
            return false;
          }

          if (column.type === 'string' || column.type === 'number' || column.type === 'boolean') {
            input[inputValueIndex] = Object.assign({}, input[inputValueIndex], _defineProperty({}, columnName, column.meta.value));
          } else if (column.type === 'object') {
            input[inputValueIndex] = Object.assign({}, input[inputValueIndex], _defineProperty({}, columnName, Object.assign({}, (0, _get2.default)(input, '[' + inputValueIndex + '][' + columnName + ']', {}), {
              key: column.meta.key,
              value: column.meta.value
            })));
          } else if (column.type === 'objectmeta') {
            input[inputValueIndex] = Object.assign({}, input[inputValueIndex], _defineProperty({}, columnName, Object.assign({}, (0, _get2.default)(input, '[' + inputValueIndex + '][' + columnName + ']', {}), {
              key: column.meta.name,
              value: _this4.unflattenChildren(state, columnName, node.children, {})
            })));
          } else if (column.type === 'arraymeta') {
            input[inputValueIndex] = Object.assign({}, input[inputValueIndex], _defineProperty({}, columnName, Object.assign({}, (0, _get2.default)(input, '[' + inputValueIndex + '][' + columnName + ']', {}), {
              key: column.meta.name,
              value: _this4.unflattenChildren(state, columnName, node.children, [])
            })));
          }
        });

        depth === 0 && inputValueIndex++;
      });

      return input;
    }
  }, {
    key: 'getImmutablePathValue',
    value: function getImmutablePathValue(node, path) {
      if (!node) {
        return;
      }
      return node.getIn(path);
    }
  }, {
    key: 'createAction',
    value: function createAction(source, type, payload) {
      switch (type) {
        case 'create':
          return {
            source: source,
            type: type,
            payload: payload
          };
        case 'edit':
          return {
            source: source,
            type: type,
            payload: {
              meta: payload
            }
          };
        case 'move':
          return {
            source: source,
            type: type,
            payload: payload
          };
        case 'delete':
          return {
            source: source,
            type: type,
            payload: payload
          };
        case 'expand':
          return {
            source: source,
            type: type
          };
        case 'collapse':
          return {
            source: source,
            type: type
          };
        default:
          return {
            source: source,
            type: type,
            payload: payload
          };
      }
    }
  }, {
    key: 'getEmptyRow',
    value: function getEmptyRow(config) {
      var id = this.getId();
      var values = {
        id: id,
        depth: 0,
        columns: {}
      };

      (0, _forEach2.default)(config.columns, function (column) {
        switch (column.type) {
          case 'string':
          case 'number':
          case 'boolean':
            values.columns = Object.assign({}, values.columns, _defineProperty({}, '' + column.name, {
              type: column.type,
              meta: {
                value: ''
              }
            }));
            break;
          case 'object':
            values.columns = Object.assign({}, values.columns, _defineProperty({}, '' + column.name, {
              type: column.type,
              meta: {
                key: '',
                value: ''
              }
            }));
            break;
          default:
            break;
        }
      });

      return values;
    }
  }, {
    key: 'findIndexInOrder',
    value: function findIndexInOrder(order, nodeId) {
      return order.findIndex(function (id) {
        return '' + id === '' + nodeId;
      });
    }
  }, {
    key: 'getLastInList',
    value: function getLastInList(list) {
      return list.last();
    }
  }, {
    key: 'isMap',
    value: function isMap(maybeMap) {
      return _immutable.Map.isMap(maybeMap);
    }
  }, {
    key: 'getMaxDepth',
    value: function getMaxDepth(state) {
      var maxDepth = 0;

      (0, _forEach2.default)(state.rows, function (row) {
        row.depth > maxDepth && (maxDepth = row.depth);
      });

      return maxDepth;
    }
  }]);

  return utils;
}();

exports.default = new utils();