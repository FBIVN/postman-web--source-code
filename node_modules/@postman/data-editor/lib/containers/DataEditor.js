'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _get = require('lodash/get');

var _get2 = _interopRequireDefault(_get);

var _map = require('lodash/map');

var _map2 = _interopRequireDefault(_map);

var _reduce = require('lodash/reduce');

var _reduce2 = _interopRequireDefault(_reduce);

var _findIndex = require('lodash/findIndex');

var _findIndex2 = _interopRequireDefault(_findIndex);

var _isEqual = require('lodash/isEqual');

var _isEqual2 = _interopRequireDefault(_isEqual);

var _fbemitter = require('fbemitter');

var _reactShortcuts = require('react-shortcuts');

var _utils = require('../utilities/utils');

var _utils2 = _interopRequireDefault(_utils);

var _shortcuts = require('../shortcuts');

var _shortcuts2 = _interopRequireDefault(_shortcuts);

var _GenerateRenderers = require('../utilities/GenerateRenderers');

var _GenerateRenderers2 = _interopRequireDefault(_GenerateRenderers);

var _reducers = require('../reducers');

var _reducers2 = _interopRequireDefault(_reducers);

var _Header = require('./Header');

var _Header2 = _interopRequireDefault(_Header);

var _ListRenderer = require('../components/ListRenderer2');

var _ListRenderer2 = _interopRequireDefault(_ListRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
// import ListRenderer from '../components/ListRenderer'


var shortcutManager = new _reactShortcuts.ShortcutManager(_shortcuts2.default);

var DataEditor = function (_Component) {
  _inherits(DataEditor, _Component);

  function DataEditor(props) {
    _classCallCheck(this, DataEditor);

    var _this = _possibleConstructorReturn(this, (DataEditor.__proto__ || Object.getPrototypeOf(DataEditor)).call(this, props));

    _this.generateGridToColumnMap(props.config.columns);

    var shortCircuitInput = _utils2.default.isMap(props.input);
    var flattenedNodes = shortCircuitInput ? {
      state: props.input,
      maxDepth: _utils2.default.getMaxDepth(props.input)
    } : _utils2.default.flattenNodes(props.config, props.input);

    _this.state = {
      is: flattenedNodes.state,
      columnWidths: (0, _map2.default)(_this.GridToColumnMap, function (c) {
        return c.width;
      })

      // console.log(this.state.is.toJS())

    };_this.listConfig = {
      widths: _this.state.columnWidths,
      cellWidth: 260 + flattenedNodes.maxDepth * 20,
      height: props.config.height
    };

    _this.reducer = new _reducers2.default(props.config);
    _this.initializeRenderers(props.config);

    _this.events = new _fbemitter.EventEmitter();

    _this.handleColumnResize = _this.handleColumnResize.bind(_this);
    _this.handleColumnClick = _this.handleColumnClick.bind(_this);
    _this.handleAction = _this.handleAction.bind(_this);
    _this.moveToCell = _this.moveToCell.bind(_this);
    _this._renderColumn = _this._renderColumn.bind(_this);
    _this._renderRow = _this._renderRow.bind(_this);
    return _this;
  }

  _createClass(DataEditor, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        events: this.events,
        shortcuts: shortcutManager
      };
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      !_utils2.default.isMap(this.props.input) && this.generateCreateRow(this.props.config);
      this.events.addListener('moveToCell', this.moveToCell);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (!(0, _isEqual2.default)(this.props.config.columns, nextProps.config.columns)) {
        this.generateGridToColumnMap(nextProps.config.columns);
        var widths = (0, _map2.default)(this.GridToColumnMap, function (c) {
          return c.width;
        });
        this.listConfig = Object.assign({}, this.listConfig, {
          widths: widths
        });
        this.setState({
          columnWidths: widths
        });
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.events.removeAllListeners('moveToCell');
    }
  }, {
    key: 'generateGridToColumnMap',
    value: function generateGridToColumnMap(columns) {
      this.GridToColumnMap = (0, _reduce2.default)(columns, function (map, column) {
        if (!column.hidden) {
          if (column.type === 'string' || column.type === 'number' || column.type === 'boolean') {
            map.push({
              name: column.name,
              index: 0,
              width: column.width,
              renderer: (0, _get2.default)(column, 'renderer'),
              header: (0, _get2.default)(column, 'label', column.name),
              resize: !!column.resize
            });
          } else if (column.type === 'object' || column.type === 'array') {
            map.push({
              name: column.name,
              index: 0,
              width: column.width / 2,
              renderer: (0, _get2.default)(column, 'renderer'),
              header: (0, _get2.default)(column, 'label.key', column.name),
              resize: !!column.resize
            });
            map.push({
              name: column.name,
              index: 1,
              width: column.width / 2,
              renderer: (0, _get2.default)(column, 'renderer'),
              header: (0, _get2.default)(column, 'label.value', column.name),
              resize: !!column.resize
            });
          }
        }

        return map;
      }, []);
    }
  }, {
    key: 'initializeRenderers',
    value: function initializeRenderers(config) {
      this.renderers = (0, _GenerateRenderers2.default)(config.renderers);
    }
  }, {
    key: 'generateCreateRow',
    value: function generateCreateRow(config) {
      var _this2 = this;

      this.setState(function (state) {
        return {
          is: _this2.reducer.reduce(state.is, {
            source: {},
            type: 'create'
          })
        };
      });
    }
  }, {
    key: 'handleColumnResize',
    value: function handleColumnResize(columnWidths) {
      this.listConfig = Object.assign({}, this.listConfig, {
        widths: columnWidths
      });

      this.setState({
        columnWidths: columnWidths
      });
    }
  }, {
    key: 'handleColumnClick',
    value: function handleColumnClick(rowIndex, columnIndex) {
      this.events.emit('focusCell', {
        node: _utils2.default.getImmutablePathValue(this.state.is, ['order', rowIndex]),
        column: (0, _get2.default)(this.GridToColumnMap, '[' + columnIndex + '].name')
      });
    }
  }, {
    key: 'handleAction',
    value: function handleAction(source, actionType, actionPayload) {
      var _this3 = this;

      var order = _utils2.default.getImmutablePathValue(this.state.is, ['order']);
      // TODO:: handle maxDepth as well (when adding a child)
      if (actionType === 'edit' && _utils2.default.getLastInList(order) === source.node) {
        // If you edited the last row (the create row), add a create row
        this.generateCreateRow();
      }

      this.setState(function (state) {
        var action = _utils2.default.createAction(source, actionType, actionPayload);

        return {
          is: _this3.reducer.reduce(state.is, action)
        };
      }, function () {
        _this3.props.onChange && _this3.props.onChange(_this3.state.is);
      });
    }
  }, {
    key: 'moveToCell',
    value: function moveToCell(_ref) {
      var node = _ref.node,
          column = _ref.column,
          direction = _ref.direction;

      var order = _utils2.default.getImmutablePathValue(this.state.is, ['order']),
          columns = this.GridToColumnMap,
          currentNodeIndex = _utils2.default.findIndexInOrder(order, node),
          currentColumnIndex = (0, _findIndex2.default)(columns, function (c) {
        return c.name === column;
      }),
          nextNodeIndex = void 0,
          nextColumnIndex = void 0,
          maxRows = order.size - 1,
          maxColumns = this.GridToColumnMap.length - 1;

      switch (direction) {
        case 'left':
        case 'shiftTab':
          if (currentColumnIndex - 1 >= 0) {
            nextNodeIndex = currentNodeIndex;
            nextColumnIndex = currentColumnIndex - 1;
          } else if (currentNodeIndex - 1 >= 0) {
            nextNodeIndex = currentNodeIndex - 1;
            nextColumnIndex = maxColumns;
          }

          this.events.emit('focusCell', {
            node: _utils2.default.getImmutablePathValue(this.state.is, ['order', nextNodeIndex]),
            column: (0, _get2.default)(this.GridToColumnMap, '[' + nextColumnIndex + '].name'),
            direction: direction
          });
          break;
        case 'right':
        case 'tab':
          if (currentColumnIndex + 1 <= maxColumns) {
            nextNodeIndex = currentNodeIndex;
            nextColumnIndex = currentColumnIndex + 1;
          } else if (currentNodeIndex + 1 <= maxRows) {
            nextNodeIndex = currentNodeIndex + 1;
            nextColumnIndex = 0;
          }

          this.events.emit('focusCell', {
            node: _utils2.default.getImmutablePathValue(this.state.is, ['order', nextNodeIndex]),
            column: (0, _get2.default)(this.GridToColumnMap, '[' + nextColumnIndex + '].name'),
            direction: direction
          });
          break;
        case 'up':
          if (currentNodeIndex - 1 >= 0) {
            nextNodeIndex = _utils2.default.getImmutablePathValue(this.state.is, ['order', currentNodeIndex - 1]);
            this.events.emit('focusCell', { node: nextNodeIndex, column: column, direction: direction });
          }
          break;
        case 'down':
          if (currentNodeIndex + 1 <= maxRows) {
            nextNodeIndex = _utils2.default.getImmutablePathValue(this.state.is, ['order', currentNodeIndex + 1]);
            this.events.emit('focusCell', { node: nextNodeIndex, column: column, direction: direction });
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: '_renderColumn',
    value: function _renderColumn(_ref2) {
      var rowIndex = _ref2.rowIndex,
          columnIndex = _ref2.columnIndex;

      var ISRowIndex = _utils2.default.getImmutablePathValue(this.state.is, ['order', rowIndex]);
      var node = _utils2.default.getImmutablePathValue(this.state.is, ['rows', '' + ISRowIndex, 'columns', this.GridToColumnMap[columnIndex].name]);
      var nodeId = ISRowIndex;

      if (!node) {
        return;
      }

      var type = _utils2.default.getImmutablePathValue(node, ['type']);
      var depth = _utils2.default.getImmutablePathValue(this.state.is, ['rows', '' + ISRowIndex, 'depth']);
      var marginLeft = depth * 20 + 'px';
      var meta = _utils2.default.getImmutablePathValue(node, ['meta']);
      var isCollapsed = !!_utils2.default.getImmutablePathValue(this.state.is, ['collapsedRows', '' + nodeId]);

      if (this.GridToColumnMap[columnIndex].renderer) {
        return this.GridToColumnMap[columnIndex].renderer && typeof this.GridToColumnMap[columnIndex].renderer === 'function' && this.GridToColumnMap[columnIndex].renderer(meta, this.handleAction.bind(this, {
          node: nodeId,
          column: this.GridToColumnMap[columnIndex].name
        }), {
          isCollapsed: isCollapsed,
          subColumnIndex: this.GridToColumnMap[columnIndex].index
        }, { marginLeft: marginLeft }, { node: nodeId, column: this.GridToColumnMap[columnIndex].name });
      }

      return this.renderers && this.renderers[type] && typeof this.renderers[type] === 'function' && this.renderers[type](meta, this.handleAction.bind(this, {
        node: nodeId,
        column: this.GridToColumnMap[columnIndex].name
      }), {
        isCollapsed: isCollapsed,
        subColumnIndex: this.GridToColumnMap[columnIndex].index
      }, { marginLeft: marginLeft }, { node: nodeId, column: this.GridToColumnMap[columnIndex].name });
    }
  }, {
    key: '_renderRow',
    value: function _renderRow(children, index, style) {
      var nodeId = _utils2.default.getImmutablePathValue(this.state.is, ['order', index]);
      return this.renderers.row && this.renderers.row({ children: children, index: index, nodeId: nodeId }, this.handleAction.bind(this, { node: nodeId }), { isCollapsed: false, subColumnIndex: 0 }, style);
    }
  }, {
    key: 'render',
    value: function render() {
      var rowCount = _utils2.default.getImmutablePathValue(this.state.is, ['order']).size;
      return _react2.default.createElement(
        'div',
        { className: 'data-editor' },
        _react2.default.createElement(_Header2.default, {
          columns: this.GridToColumnMap,
          columnWidths: this.state.columnWidths,
          renderers: this.renderers,
          onColumnResize: this.handleColumnResize
        }),
        _react2.default.createElement(_ListRenderer2.default, {
          state: this.state.is // Dummy to force rerenders when state changes
          , rowCount: rowCount,
          columnCount: this.GridToColumnMap.length,
          config: this.listConfig,
          cellRenderer: this._renderColumn,
          rowRenderer: this._renderRow,
          className: this.props.className,
          classNames: this.props.config.classNames,
          onColumnClick: this.handleColumnClick
        })
      );
    }
  }]);

  return DataEditor;
}(_react.Component);

DataEditor.childContextTypes = {
  shortcuts: _propTypes2.default.object.isRequired,
  events: _propTypes2.default.object
};

exports.default = DataEditor;