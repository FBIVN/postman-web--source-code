'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var MoveReducer = function MoveReducer(state, _ref, _ref2) {
  var node = _ref.node;
  var sourceIndex = _ref2.sourceIndex,
      position = _ref2.position;

  // node is the row index that as moved
  // destination is the row index that node was moved after
  var order = state.getIn(['order']);
  var destinationNodeId = node;
  var sourceNodeId = order.get(sourceIndex);
  var destinationNodeIndex = order.indexOf(destinationNodeId);
  position === 'before' && (destinationNodeIndex -= 1);

  if (destinationNodeIndex === order.size - 1 || sourceIndex === order.size - 1) {
    // If the last row was moved, or a node was moved to the last row, stop it, because
    // the last row is the create row
    return state;
  }

  // Get the actual IDs of the row that was moved
  // let nodeId = order.get(node);

  // Get the destination's children
  var nodeChildren = state.getIn(['rows', '' + destinationNodeId, 'allChildren']);

  // Delete the source node and it's children from the order list
  order = order.delete(sourceIndex);
  if (nodeChildren) {
    nodeChildren.forEach(function () {
      order = order.delete(sourceIndex);
    });
  }

  // Add the node and it's children to the order array at the correct indices

  // Since children are involved and we are working with indices, and we've
  // deleted them all in the previous section, it matters if the row was dropped before
  // or after it's own index.

  // If the row was dropped after it's own index, it's simple. Deletes would not have affected
  // the indeices we are supposed to insert children to.
  if (sourceIndex > destinationNodeIndex) {
    order = order.insert(destinationNodeIndex + 1, sourceNodeId);
    if (nodeChildren) {
      nodeChildren.forEach(function (child, index) {
        order = order.insert(destinationNodeIndex + 1 + index + 1, child);
      });
    }
  }
  // However, if the row was dropped before it's own index, deletes would have messed with
  // the index the children have to be inserted at. We have to (mathematically) adjust indices accordingly
  else {
      if (nodeChildren) {
        order = order.insert(destinationNodeIndex - nodeChildren.size, sourceNodeId);
        nodeChildren.forEach(function (child, index) {
          order = order.insert(destinationNodeIndex + index + 1 - nodeChildren.size, child);
        });
      } else {
        order = order.insert(destinationNodeIndex, sourceNodeId);
      }
    }

  // Set the order list in the state
  state = state.setIn(['order'], order);
  return state;
};

exports.default = MoveReducer;