var marked = require('marked'),
  sanitize = require('sanitize-html');

/**
 * Santize HTML output based on options
 *
 * @param {String} content - HTML string
 * @param {Object} options - sanitize options
 * @param {Boolean} options.inline - allow only inline tags
 * @returns {String} sanitized HTML string
 */
function sanitizeHtml (content, options) {
  var HTML_DEFAULT_OPTIONS = {
      allowedTags: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'p', 'a', 'ul', 'ol', 'nl', 'li', 'b', 'i',
        'strong', 'em', 'strike', 'code', 'hr', 'br', 'div', 'table', 'thead', 'caption', 'tbody', 'tr', 'th', 'td',
        'pre', 'img', 'abbr', 'address', 'section', 'article', 'aside', 'dd', 'dl', 'dt', 'tfoot'],
      allowedAttributes: {
        a: ['href'],
        img: ['src', 'width', 'height'],
        div: ['class'],
        pre: ['class'],
        h1: ['id']
      }
    },
    INLINE_HTML_OPTIONS = {
      allowedTags: ['a', 'b', 'i', 'strong', 'em', 'strike', 'br'],
      allowedAttributes: {
        a: ['href']
      }
    },
    options = options.inline ? INLINE_HTML_OPTIONS : HTML_DEFAULT_OPTIONS;

  return sanitize(content, options);
}

/**
 * Parse input string as markdown with provided options
 * and santize the resulting HTML
 */
module.exports = function (source, markedOptions, sanitizeOptions) {
  if (typeof source !== 'string') {
    return '';
  }

  var options = {
    gfm: true,
    tables: true,
    breaks: false,
    pedantic: false,
    sanitize: false, // We'll be sanitizing separately using sanitize-html
    smartLists: true,
    smartypants: false
  };

  Object.keys(markedOptions || {}).forEach(function (key) {
    options[key] = markedOptions[key]
  });

  // Set the default markdown options
  marked.setOptions(options);

  return sanitizeHtml(marked(source), sanitizeOptions || {});
}
